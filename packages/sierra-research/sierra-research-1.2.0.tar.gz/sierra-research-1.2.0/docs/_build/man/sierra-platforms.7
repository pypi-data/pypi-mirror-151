.\" Man page generated from reStructuredText.
.
.
.nr rst2man-indent-level 0
.
.de1 rstReportMargin
\\$1 \\n[an-margin]
level \\n[rst2man-indent-level]
level margin: \\n[rst2man-indent\\n[rst2man-indent-level]]
-
\\n[rst2man-indent0]
\\n[rst2man-indent1]
\\n[rst2man-indent2]
..
.de1 INDENT
.\" .rstReportMargin pre:
. RS \\$1
. nr rst2man-indent\\n[rst2man-indent-level] \\n[an-margin]
. nr rst2man-indent-level +1
.\" .rstReportMargin post:
..
.de UNINDENT
. RE
.\" indent \\n[an-margin]
.\" old: \\n[rst2man-indent\\n[rst2man-indent-level]]
.nr rst2man-indent-level -1
.\" new: \\n[rst2man-indent\\n[rst2man-indent-level]]
.in \\n[rst2man-indent\\n[rst2man-indent-level]]u
..
.TH "SIERRA-PLATFORMS" "7" "May 20, 2022" "1.2.0" "SIERRA"
.SH NAME
sierra-platforms \- The platforms SIERRA supports, and platform-specific Batch Criteria.
.SH ARGOS PLATFORM
.sp
This platform can be selected via \fB\-\-platform=platform.argos\fP\&.
.sp
This is the default platform on which SIERRA will run experiments, and using the
ARGoS simulator. It cannot be used to run experiments on real robots.
.SS Batch Criteria
.sp
See Batch Criteria for a thorough explanation of batch criteria, but the
short version is that they are the core of SIERRA\-\-how to get it to DO stuff for
you.  The following batch criteria are defined which can be used with any
Project\&.
.INDENT 0.0
.IP \(bu 2
\fI\%Swarm Population Size\fP
.IP \(bu 2
\fI\%Swarm Constant Population Density\fP
.IP \(bu 2
\fI\%Swarm Variable Population Density\fP
.IP \(bu 2
\fI\%Sensor and Actuator Noise\fP
.UNINDENT
.sp
You \fIshould\fP be able to combine any two of the criteria above, or use them
independently. I have not tried all combinations, so YMMV.
.SS Swarm Population Size
.sp
Changing the swarm size to investigate behavior across scales within a static
arena size (i.e., variable density). This criteria is functionally identical to
\fI\%Swarm Variable Population Density\fP in terms of changes to the template XML
file, but has a different semantic meaning which can make generated deliverables
more immediately understandable, depending on the context of what is being
investigated (e.g., swarm size vs. swarm density on the X axis).
.SS Cmdline Syntax
.sp
\fBpopulation_size.{model}{N}[.C{cardinality}]\fP
.INDENT 0.0
.IP \(bu 2
\fBmodel\fP
.INDENT 2.0
.IP \(bu 2
\fBLog\fP \- Swarm sizes for each experiment are distributed 1...N by powers
of 2.
.IP \(bu 2
\fBLinear\fP \- Swarm sizes for each experiment are distributed linearly
between 1...N, split evenly into 10 different sizes.
.UNINDENT
.IP \(bu 2
\fBN\fP \- The maximum swarm size.
.IP \(bu 2
\fBcardinality\fP \- If the model is \fBLinear\fP, then this can be used
to specify how many experiments to generate; i.e, it defines the \fIsize\fP of the
linear increment. Defaults to 10 if omitted.
.UNINDENT
.SS Examples
.INDENT 0.0
.IP \(bu 2
\fBpopulation_size.Log1024\fP: Static swarm sizes 1...1024
.IP \(bu 2
\fBpopulation_size.Linear1000\fP: Static swarm sizes 100...1000 (10)
.IP \(bu 2
\fBpopulation_size.Linear3.C3\fP: Static swarm sizes 1...3 (3)
.IP \(bu 2
\fBpopulation_size.Linear10.C2\fP: Static swarm sizes 5...10 (2)
.UNINDENT
.SS Swarm Constant Population Density
.sp
Changing the swarm size and arena size together to maintain the same swarm
size/arena size ratio to investigate behavior across scales.
.sp
\fBNOTE:\fP
.INDENT 0.0
.INDENT 3.5
This criteria is for \fIconstant\fP density of robots as swarm sizes
increase. For \fIvariable\fP robot density, use
\fI\%Swarm Population Size\fP or
\fI\%Swarm Variable Population Density\fP\&.
.UNINDENT
.UNINDENT
.SS Cmdline Syntax
.sp
\fBpopulation_constant_density.{density}.I{Arena Size Increment}.C{cardinality}\fP
.INDENT 0.0
.IP \(bu 2
\fBdensity\fP \- <integer>p<integer> (i.e. 5p0 for 5.0)
.IP \(bu 2
.INDENT 2.0
.TP
.B \fBArena Size Increment\fP \- Size in meters that the X and Y dimensions should
increase by in between experiments. Larger values here will result in larger
arenas and more robots being simulated at a given density. Must be an
integer.
.UNINDENT
.IP \(bu 2
\fBcardinality\fP How many experiments should be generated?
.UNINDENT
.SS Examples
.INDENT 0.0
.IP \(bu 2
.INDENT 2.0
.TP
.B \fBpopulation_constant_density.1p0.I16.C4\fP: Constant density of 1.0. Arena
dimensions will increase by 16 in both X and Y for each experiment in the
batch (4 total).
.UNINDENT
.UNINDENT
.SS Swarm Variable Population Density
.sp
Changing the swarm size to investigate behavior across scales within a static
arena size. This criteria is functionally identical to
\fI\%Swarm Population Size\fP in terms of changes to the template
XML file, but has a different semantic meaning which can make generated
deliverables more immediately understandable, depending on the context of what
is being investigated (e.g., swarm density vs. swarm size on the X axis).
.sp
\fBNOTE:\fP
.INDENT 0.0
.INDENT 3.5
This criteria is for \fIvariable\fP density of robots as swarm sizes
increase. For \fIconstant\fP robot density, use
\fI\%Swarm Constant Population Density\fP\&.
.UNINDENT
.UNINDENT
.SS Cmdline Syntax
.sp
\fBpopulation_variable_density.{density_min}.{density_max}.C{cardinality}\fP
.INDENT 0.0
.IP \(bu 2
\fBdensity_min\fP \- <integer>p<integer> (i.e. 5p0 for 5.0)
.IP \(bu 2
\fBdensity_max\fP \- <integer>p<integer> (i.e. 5p0 for 5.0)
.IP \(bu 2
\fBcardinality\fP How many experiments should be generated? Densities for each
experiment will be linearly spaced between the min and max densities.
.UNINDENT
.SS Examples
.INDENT 0.0
.IP \(bu 2
\fBpopulation_variable_density.1p0.4p0.C4\fP: Densities of 1.0,2.0,3.0,4.0.
.UNINDENT
.SS Sensor and Actuator Noise
.sp
Inject sensor and/or actuator noise into the swarm.
.SS Cmdline Syntax
.sp
\fBsaa_noise.{category}.C{cardinality}[.Z{population}]\fP
.INDENT 0.0
.IP \(bu 2
\fBcategory\fP \- [sensors,actuators,all]
.INDENT 2.0
.IP \(bu 2
\fBsensors\fP \- Apply noise to robot sensors only. The \fBsensors\fP dictionary
must be present and non\-empty in the \fBmain.yaml\fP\&.
.IP \(bu 2
\fBactuators\fP \- Apply noise to robot actuators only. The \fBactuators\fP
dictionary must be present and non\-empty in \fBmain.yaml\fP\&.
.IP \(bu 2
\fBall\fP \- Apply noise to robot sensors AND actuators. [ \fBsensors\fP,
\fBactuators\fP ] dictionaries both optional in \fBmain.yaml\fP\&.
.UNINDENT
.IP \(bu 2
\fBcardinality\fP \- The # of different noise levels to test with between the min
and max specified in the config file for each sensor/actuator which defines
the cardinality of the batch experiment.
.IP \(bu 2
\fBpopulation\fP \- The static swarm size to use (optional).
.UNINDENT
.SS Examples
.INDENT 0.0
.IP \(bu 2
\fBsaa_noise.sensors.C4.Z16\fP: 4 levels of noise applied to all sensors in a
swarm of size 16.
.IP \(bu 2
\fBsaa_noise.actuators.C3.Z32\fP: 3 levels of noise applied to all actuators in
a swarm of size 32.
.IP \(bu 2
\fBsaa_noise.all.C10\fP: 10 levels of noise applied to both sensors and
actuators; swarm size not modified.
.UNINDENT
.sp
The values for the min, max noise levels for each sensor which are used along
with \fBcardinality\fP to define the set of noise ranges to test are set via the
main YAML configuration file (not an easy way to specify ranges in a single
batch criteria definition string). The relevant section is shown below. If the
min, max level for a sensor/actuator is not specified in the YAML file, no XML
changes will be generated for it.
.sp
\fBIMPORTANT:\fP
.INDENT 0.0
.INDENT 3.5
In order to use this batch criteria, you \fBMUST\fP have the version of ARGoS
from \fI\%Swarm Robotics Research\fP\&.
The version accessible on the ARGoS website does not have a consistent noise
injection interface, making usage with this criteria impossible.
.UNINDENT
.UNINDENT
.sp
The following sensors can be affected (dependent on your chosen robot\(aqs
capabilities in ARGoS):
.INDENT 0.0
.IP \(bu 2
light
.IP \(bu 2
proximity
.IP \(bu 2
ground
.IP \(bu 2
steering
.IP \(bu 2
position
.UNINDENT
.sp
The following actuators can be affected (dependent on your chosen robot\(aqs
capabilities in ARGoS):
.INDENT 0.0
.IP \(bu 2
steering
.UNINDENT
.SS YAML Config
.sp
For all sensors and actuators to which noise should be applied, the noise model
and dependent parameters must be specified (i.e. if a given sensor or sensor is
present in the config, all config items for it are mandatory).
.sp
The appropriate \fBticks_range\fP attribute is required, as there is no way to
calculate in general what the correct range of X values for generated graphs
should be, because some sensors/actuators may have different
assumptions/requirements about noise application than others. For example, the
differential steering actuator \fBnoise_factor\fP has a default value of 1.0
rather than 0.0, due to its implementation model in ARGoS, so the same range of
noise applied to it and, say, the ground sensor, will have different XML changes
generated, and so you can\(aqt just average the ranges for all sensors/actuators to
compute what the ticks should be for a given experiment.
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
perf:
  ...
  robustness:
    # For \(ga\(gauniform\(ga\(ga models, the \(ga\(gauniform_ticks_range\(ga\(ga attributes are
    # required.
    uniform_ticks_range: [0.0, 0.1]

    # For \(ga\(gagaussian\(ga\(ga models, the \(ga\(gagaussian_ticks_stddev_range\(ga\(ga and
    # \(ga\(gagaussian_ticks_mean_range\(ga\(ga attributes are required.
    gaussian_ticks_mean_range: [0.0, 0.1]
    gaussian_ticks_stddev_range: [0.0, 0.0]

    # For \(ga\(gagaussian\(ga\(ga models, the \(ga\(gagaussian_labels_show\(ga\(ga,
    # \(ga\(gagaussian_ticks_src\(ga\(ga attributes are required, and control what is
    # shown for the xticks/xlabels: the mean or stddev values.
    gaussian_ticks_src: stddev
    gaussian_labels_show: stddev

    # The sensors to inject noise into. All shown sensors are optional. If
    # omitted, they will not be affected by noise injection.
    sensors:
      light:
        model: uniform

        # For a \(ga\(gauniform\(ga\(ga model, the \(ga\(garange\(ga\(ga attribute is required, and
        # defines the \-[level, level] distribution that injected noise will
        # be drawn from.
        range: [0.0, 0.4]

      proximity:
        model: gaussian
        stddev_range: [0.0, 0.1]
        mean_range: [0.0, 0.0]
      ground:
        model: gaussian
        stddev_range: [0.0, 0.1]
        mean_range: [0.0, 0.0]
      steering: # applied to [vel_noise, dist_noise]
        model: uniform
        range: [0.0, 0.1]
      position:
        model: uniform
        range: [0.0, 0.1]

      # The actuators to inject noise into. All shown actuators are
      # optional. If omitted, they will not be affected by noise injection.
      actuators:
        steering: # applied to [noise_factor]
          model: uniform
          range: [0.95, 1.05]
.ft P
.fi
.UNINDENT
.UNINDENT
.SS Uniform Noise Injection Examples
.INDENT 0.0
.IP \(bu 2
\fBrange: [0.0,0.1]\fP with \fBcardinality=1\fP will result in two experiments
with uniform noise distributions of \fB[0.0, 0.0]\fP, and \fB[\-0.1, 0.1]\fP\&.
.UNINDENT
.SS Gaussian Noise Injection Examples
.INDENT 0.0
.IP \(bu 2
\fBstddev_range: [0.0,1.0]\fP and \fBmean_range: [0.0, 0.0]\fP with
\fBcardinality=2\fP will result in two experiments with Guassian noise
distributions of \fBGaussian(0,0)\fP, \fBGaussian(0, 0.5)\fP, and \fBGaussian(0,
1.0)\fP\&.
.UNINDENT
.SS Experiment Definitions
.INDENT 0.0
.IP \(bu 2
exp0 \- Ideal conditions, in which noise will be applied to the specified
sensors and/or actuators at the lower bound of the specified ranges for each.
.IP \(bu 2
exp1\-expN \- Increasing levels of noise, using the cardinality specified on the
command line and the distribution type specified in YAML configuration.
.UNINDENT
.SS Random Seeding For Reproducibility
.sp
ARGoS provides its own random seed mechanism under \fB<experiment>\fP which SIERRA
uses to seed each experiment. Project code should use this mechanism or
a similar random seed generator manager seeded by the same value so that
experiments can be reproduced exactly. By default SIERRA does not overwrite its
generated random seeds for each experiment once generated; you can override with
\fB\-\-no\-preserve\-seeds\fP\&. See ln\-tutorials\-project\-template\-input\-file and
ln\-req\-exp for details on the format of the provided seed.
.SH ROS+GAZEBO PLATFORM
.sp
This platform can be selected via \fB\-\-platform=platform.rosgazebo\fP\&.
.sp
This is the platform on which SIERRA will run experiments using the
Gazebo simulator and ROS (either ROS1 OR ROS2). It cannot be
used to run experiments on real robots. To use this platform, you must setup the
SIERRA ROSBridge\&.
.SS Batch Criteria
.sp
See Batch Criteria for a thorough explanation of batch criteria, but the
short version is that they are the core of SIERRA\-\-how to get it to DO stuff for
you.  The following batch criteria are defined which can be used with any
Project\&.
.INDENT 0.0
.IP \(bu 2
\fI\%System Population Size\fP
.UNINDENT
.SS System Population Size
.sp
Changing the system size to investigate behavior across scales within a static
arena size (i.e., variable density). Systems are homogeneous.
.SS Cmdline Syntax
.sp
\fBpopulation_size.{model}{N}[.C{cardinality}]\fP
.INDENT 0.0
.IP \(bu 2
\fBmodel\fP
.INDENT 2.0
.IP \(bu 2
\fBLog\fP \- Swarm sizes for each experiment are distributed 1...N by powers
of 2.
.IP \(bu 2
\fBLinear\fP \- Swarm sizes for each experiment are distributed linearly
between 1...N, split evenly into 10 different sizes.
.UNINDENT
.IP \(bu 2
\fBN\fP \- The maximum swarm size.
.IP \(bu 2
\fBcardinality\fP \- If the model is \fBLinear\fP, then this can be used
to specify how many experiments to generate; i.e, it defines the \fIsize\fP of the
linear increment. Defaults to 10 if omitted.
.UNINDENT
.SS Examples
.INDENT 0.0
.IP \(bu 2
\fBpopulation_size.Log1024\fP: Static swarm sizes 1...1024
.IP \(bu 2
\fBpopulation_size.Linear1000\fP: Static swarm sizes 100...1000 (10)
.IP \(bu 2
\fBpopulation_size.Linear3.C3\fP: Static swarm sizes 1...3 (3)
.IP \(bu 2
\fBpopulation_size.Linear10.C2\fP: Static swarm sizes 5...10 (2)
.UNINDENT
.SS Random Seeding For Reproducibility
.sp
ROS+Gazebo do not provide a random number generator manager, but SIERRA provides
random seeds to each Experimental Run which Project code should
use to manage random number generation, if needed, to maximize
reproducability. See ln\-tutorials\-project\-template\-input\-file and
ln\-req\-exp for details on the format of the provided seed. By default
SIERRA does not overwrite its generated random seeds for each experiment once
generated; you can override with \fB\-\-no\-preserve\-seeds\fP\&.
.SH ROS+ROBOT PLATFORM
.sp
This platform can be selected via \fB\-\-platform=platform.rosrobot\fP\&.
.sp
This is the platform on which SIERRA will run experiments using ROS
(either ROS1 OR ROS2) on a real robot of your choice. To use this platform, you
must setup the SIERRA ROSBridge\&.
.SS Random Seeding For Reproducibility
.sp
ROS do not provide a random number generator manager, but SIERRA provides random
seeds to each Experimental Run which Project code should use to
manage random number generation, if needed, to maximize reproducability. See
ln\-tutorials\-project\-template\-input\-file and ln\-req\-exp for
details on the format of the provided seed. By default SIERRA does not overwrite
its generated random seeds for each experiment once generated; you can override
with \fB\-\-no\-preserve\-seeds\fP\&.
.SH AUTHOR
John Harwell
.SH COPYRIGHT
2022, John Harwell
.\" Generated by docutils manpage writer.
.
