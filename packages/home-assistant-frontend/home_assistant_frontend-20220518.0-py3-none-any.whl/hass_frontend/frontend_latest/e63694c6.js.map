{"version":3,"file":"e63694c6.js","mappings":";;AAwFA;;AAIA;;;AAKA;AACA;;;AAOA;AAEA;;;;AAxBA;;;;;;;;;;;;;;;;;;;;;;;;;;AApCA","sources":["webpack://home-assistant-frontend/./src/panels/lovelace/cards/energy/hui-energy-solar-graph-card.ts"],"sourcesContent":["import {\n  ChartData,\n  ChartDataset,\n  ChartOptions,\n  ScatterDataPoint,\n} from \"chart.js\";\nimport {\n  addHours,\n  differenceInDays,\n  endOfToday,\n  isToday,\n  startOfToday,\n} from \"date-fns/esm\";\nimport { UnsubscribeFunc } from \"home-assistant-js-websocket\";\nimport { css, CSSResultGroup, html, LitElement, TemplateResult } from \"lit\";\nimport { customElement, property, state } from \"lit/decorators\";\nimport { classMap } from \"lit/directives/class-map\";\nimport memoizeOne from \"memoize-one\";\nimport {\n  hex2rgb,\n  lab2rgb,\n  rgb2hex,\n  rgb2lab,\n} from \"../../../../common/color/convert-color\";\nimport { labBrighten, labDarken } from \"../../../../common/color/lab\";\nimport { formatTime } from \"../../../../common/datetime/format_time\";\nimport { computeStateName } from \"../../../../common/entity/compute_state_name\";\nimport {\n  formatNumber,\n  numberFormatToLocale,\n} from \"../../../../common/number/format_number\";\nimport \"../../../../components/chart/ha-chart-base\";\nimport \"../../../../components/ha-card\";\nimport {\n  EnergyData,\n  EnergySolarForecasts,\n  getEnergyDataCollection,\n  getEnergySolarForecasts,\n  SolarSourceTypeEnergyPreference,\n} from \"../../../../data/energy\";\nimport { FrontendLocaleData } from \"../../../../data/translation\";\nimport { SubscribeMixin } from \"../../../../mixins/subscribe-mixin\";\nimport { HomeAssistant } from \"../../../../types\";\nimport { LovelaceCard } from \"../../types\";\nimport { EnergySolarGraphCardConfig } from \"../types\";\n\n@customElement(\"hui-energy-solar-graph-card\")\nexport class HuiEnergySolarGraphCard\n  extends SubscribeMixin(LitElement)\n  implements LovelaceCard\n{\n  @property({ attribute: false }) public hass!: HomeAssistant;\n\n  @state() private _config?: EnergySolarGraphCardConfig;\n\n  @state() private _chartData: ChartData = {\n    datasets: [],\n  };\n\n  @state() private _start = startOfToday();\n\n  @state() private _end = endOfToday();\n\n  protected hassSubscribeRequiredHostProps = [\"_config\"];\n\n  public hassSubscribe(): UnsubscribeFunc[] {\n    return [\n      getEnergyDataCollection(this.hass, {\n        key: this._config?.collection_key,\n      }).subscribe((data) => this._getStatistics(data)),\n    ];\n  }\n\n  public getCardSize(): Promise<number> | number {\n    return 3;\n  }\n\n  public setConfig(config: EnergySolarGraphCardConfig): void {\n    this._config = config;\n  }\n\n  protected render(): TemplateResult {\n    if (!this.hass || !this._config) {\n      return html``;\n    }\n\n    return html`\n      <ha-card>\n        ${this._config.title\n          ? html`<h1 class=\"card-header\">${this._config.title}</h1>`\n          : \"\"}\n        <div\n          class=\"content ${classMap({\n            \"has-header\": !!this._config.title,\n          })}\"\n        >\n          <ha-chart-base\n            .data=${this._chartData}\n            .options=${this._createOptions(\n              this._start,\n              this._end,\n              this.hass.locale\n            )}\n            chart-type=\"bar\"\n          ></ha-chart-base>\n          ${!this._chartData.datasets.length\n            ? html`<div class=\"no-data\">\n                ${isToday(this._start)\n                  ? this.hass.localize(\"ui.panel.lovelace.cards.energy.no_data\")\n                  : this.hass.localize(\n                      \"ui.panel.lovelace.cards.energy.no_data_period\"\n                    )}\n              </div>`\n            : \"\"}\n        </div>\n      </ha-card>\n    `;\n  }\n\n  private _createOptions = memoizeOne(\n    (start: Date, end: Date, locale: FrontendLocaleData): ChartOptions => {\n      const dayDifference = differenceInDays(end, start);\n      return {\n        parsing: false,\n        animation: false,\n        scales: {\n          x: {\n            type: \"time\",\n            suggestedMin: start.getTime(),\n            suggestedMax: end.getTime(),\n            adapters: {\n              date: {\n                locale: locale,\n              },\n            },\n            ticks: {\n              maxRotation: 0,\n              sampleSize: 5,\n              autoSkipPadding: 20,\n              major: {\n                enabled: true,\n              },\n              font: (context) =>\n                context.tick && context.tick.major\n                  ? ({ weight: \"bold\" } as any)\n                  : {},\n            },\n            time: {\n              tooltipFormat:\n                dayDifference > 35\n                  ? \"monthyear\"\n                  : dayDifference > 7\n                  ? \"date\"\n                  : dayDifference > 2\n                  ? \"weekday\"\n                  : dayDifference > 0\n                  ? \"datetime\"\n                  : \"hour\",\n              minUnit:\n                dayDifference > 35\n                  ? \"month\"\n                  : dayDifference > 2\n                  ? \"day\"\n                  : \"hour\",\n            },\n            offset: true,\n          },\n          y: {\n            stacked: true,\n            type: \"linear\",\n            title: {\n              display: true,\n              text: \"kWh\",\n            },\n            ticks: {\n              beginAtZero: true,\n            },\n          },\n        },\n        plugins: {\n          tooltip: {\n            mode: \"nearest\",\n            callbacks: {\n              title: (datasets) => {\n                if (dayDifference > 0) {\n                  return datasets[0].label;\n                }\n                const date = new Date(datasets[0].parsed.x);\n                return `${formatTime(date, locale)} â€“ ${formatTime(\n                  addHours(date, 1),\n                  locale\n                )}`;\n              },\n              label: (context) =>\n                `${context.dataset.label}: ${formatNumber(\n                  context.parsed.y,\n                  locale\n                )} kWh`,\n            },\n          },\n          filler: {\n            propagate: false,\n          },\n          legend: {\n            display: false,\n            labels: {\n              usePointStyle: true,\n            },\n          },\n        },\n        hover: {\n          mode: \"nearest\",\n        },\n        elements: {\n          line: {\n            tension: 0.3,\n            borderWidth: 1.5,\n          },\n          bar: { borderWidth: 1.5, borderRadius: 4 },\n          point: {\n            hitRadius: 5,\n          },\n        },\n        // @ts-expect-error\n        locale: numberFormatToLocale(locale),\n      };\n    }\n  );\n\n  private async _getStatistics(energyData: EnergyData): Promise<void> {\n    const solarSources: SolarSourceTypeEnergyPreference[] =\n      energyData.prefs.energy_sources.filter(\n        (source) => source.type === \"solar\"\n      ) as SolarSourceTypeEnergyPreference[];\n\n    let forecasts: EnergySolarForecasts | undefined;\n    if (\n      solarSources.some((source) => source.config_entry_solar_forecast?.length)\n    ) {\n      try {\n        forecasts = await getEnergySolarForecasts(this.hass);\n      } catch (_e) {\n        // ignore\n      }\n    }\n\n    const datasets: ChartDataset<\"bar\">[] = [];\n\n    const computedStyles = getComputedStyle(this);\n    const solarColor = computedStyles\n      .getPropertyValue(\"--energy-solar-color\")\n      .trim();\n\n    const dayDifference = differenceInDays(\n      energyData.end || new Date(),\n      energyData.start\n    );\n\n    solarSources.forEach((source, idx) => {\n      const data: ChartDataset<\"bar\" | \"line\">[] = [];\n      const entity = this.hass.states[source.stat_energy_from];\n\n      const modifiedColor =\n        idx > 0\n          ? this.hass.themes.darkMode\n            ? labBrighten(rgb2lab(hex2rgb(solarColor)), idx)\n            : labDarken(rgb2lab(hex2rgb(solarColor)), idx)\n          : undefined;\n      const borderColor = modifiedColor\n        ? rgb2hex(lab2rgb(modifiedColor))\n        : solarColor;\n\n      let prevValue: number | null = null;\n      let prevStart: string | null = null;\n\n      const solarProductionData: ScatterDataPoint[] = [];\n\n      // Process solar production data.\n      if (source.stat_energy_from in energyData.stats) {\n        const stats = energyData.stats[source.stat_energy_from];\n\n        for (const point of stats) {\n          if (point.sum === null) {\n            continue;\n          }\n          if (prevValue === null) {\n            prevValue = point.sum;\n            continue;\n          }\n          if (prevStart === point.start) {\n            continue;\n          }\n          const value = point.sum - prevValue;\n          const date = new Date(point.start);\n          solarProductionData.push({\n            x: date.getTime(),\n            y: value,\n          });\n          prevStart = point.start;\n          prevValue = point.sum;\n        }\n      }\n\n      if (solarProductionData.length) {\n        data.push({\n          label: this.hass.localize(\n            \"ui.panel.lovelace.cards.energy.energy_solar_graph.production\",\n            {\n              name: entity ? computeStateName(entity) : source.stat_energy_from,\n            }\n          ),\n          borderColor,\n          backgroundColor: borderColor + \"7F\",\n          data: solarProductionData,\n          stack: \"solar\",\n        });\n      }\n\n      // Process solar forecast data.\n      if (forecasts && source.config_entry_solar_forecast) {\n        const forecastsData: Record<string, number> | undefined = {};\n        source.config_entry_solar_forecast.forEach((configEntryId) => {\n          if (!forecasts![configEntryId]) {\n            return;\n          }\n          Object.entries(forecasts![configEntryId].wh_hours).forEach(\n            ([date, value]) => {\n              const dateObj = new Date(date);\n              if (\n                dateObj < energyData.start ||\n                (energyData.end && dateObj > energyData.end)\n              ) {\n                return;\n              }\n              if (dayDifference > 35) {\n                dateObj.setDate(1);\n              }\n              if (dayDifference > 2) {\n                dateObj.setHours(0, 0, 0, 0);\n              } else {\n                dateObj.setMinutes(0, 0, 0);\n              }\n              const time = dateObj.getTime();\n              if (time in forecastsData) {\n                forecastsData[time] += value;\n              } else {\n                forecastsData[time] = value;\n              }\n            }\n          );\n        });\n\n        if (forecastsData) {\n          const solarForecastData: ScatterDataPoint[] = [];\n          for (const [time, value] of Object.entries(forecastsData)) {\n            solarForecastData.push({\n              x: Number(time),\n              y: value / 1000,\n            });\n          }\n\n          if (solarForecastData.length) {\n            data.push({\n              type: \"line\",\n              label: this.hass.localize(\n                \"ui.panel.lovelace.cards.energy.energy_solar_graph.forecast\",\n                {\n                  name: entity\n                    ? computeStateName(entity)\n                    : source.stat_energy_from,\n                }\n              ),\n              fill: false,\n              stepped: false,\n              borderColor: computedStyles.getPropertyValue(\n                \"--primary-text-color\"\n              ),\n              borderDash: [7, 5],\n              pointRadius: 0,\n              data: solarForecastData,\n            });\n          }\n        }\n      }\n\n      // Concat two arrays\n      Array.prototype.push.apply(datasets, data);\n    });\n\n    this._start = energyData.start;\n    this._end = energyData.end || endOfToday();\n\n    this._chartData = {\n      datasets,\n    };\n  }\n\n  static get styles(): CSSResultGroup {\n    return css`\n      ha-card {\n        height: 100%;\n      }\n      .card-header {\n        padding-bottom: 0;\n      }\n      .content {\n        padding: 16px;\n      }\n      .has-header {\n        padding-top: 0;\n      }\n      .no-data {\n        position: absolute;\n        height: 100%;\n        top: 0;\n        left: 0;\n        right: 0;\n        display: flex;\n        justify-content: center;\n        align-items: center;\n        padding: 20%;\n        margin-left: 32px;\n        box-sizing: border-box;\n      }\n    `;\n  }\n}\n\ndeclare global {\n  interface HTMLElementTagNameMap {\n    \"hui-energy-solar-graph-card\": HuiEnergySolarGraphCard;\n  }\n}\n"],"names":[],"sourceRoot":""}