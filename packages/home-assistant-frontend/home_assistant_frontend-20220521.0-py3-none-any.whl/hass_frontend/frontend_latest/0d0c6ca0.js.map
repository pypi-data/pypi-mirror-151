{"version":3,"file":"0d0c6ca0.js","mappings":";AAyEA;AAMA;;;;AAKA;;;AAMA;AAEA;AAIA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAtCA;;;;;;;;;;;;;;;;;;;;;AAlDA","sources":["webpack://home-assistant-frontend/./src/panels/logbook/ha-logbook.ts"],"sourcesContent":["import { css, html, LitElement, PropertyValues, TemplateResult } from \"lit\";\nimport { customElement, property, state } from \"lit/decorators\";\nimport { isComponentLoaded } from \"../../common/config/is_component_loaded\";\nimport { ensureArray } from \"../../common/ensure-array\";\nimport { computeStateDomain } from \"../../common/entity/compute_state_domain\";\nimport { throttle } from \"../../common/util/throttle\";\nimport \"../../components/ha-circular-progress\";\nimport {\n  clearLogbookCache,\n  getLogbookData,\n  LogbookEntry,\n} from \"../../data/logbook\";\nimport { loadTraceContexts, TraceContexts } from \"../../data/trace\";\nimport { fetchUsers } from \"../../data/user\";\nimport { HomeAssistant } from \"../../types\";\nimport \"./ha-logbook-renderer\";\n\n@customElement(\"ha-logbook\")\nexport class HaLogbook extends LitElement {\n  @property({ attribute: false }) public hass!: HomeAssistant;\n\n  @property() public time!:\n    | { range: [Date, Date] }\n    | {\n        // Seconds\n        recent: number;\n      };\n\n  @property() public entityIds?: string[];\n\n  @property() public deviceIds?: string[];\n\n  @property({ type: Boolean, attribute: \"narrow\" })\n  public narrow = false;\n\n  @property({ type: Boolean, attribute: \"virtualize\", reflect: true })\n  public virtualize = false;\n\n  @property({ type: Boolean, attribute: \"no-icon\" })\n  public noIcon = false;\n\n  @property({ type: Boolean, attribute: \"no-name\" })\n  public noName = false;\n\n  @property({ type: Boolean, attribute: \"relative-time\" })\n  public relativeTime = false;\n\n  @property({ type: Boolean }) public showMoreLink = true;\n\n  @state() private _logbookEntries?: LogbookEntry[];\n\n  @state() private _traceContexts?: TraceContexts;\n\n  @state() private _userIdToName = {};\n\n  @state() private _error?: string;\n\n  private _lastLogbookDate?: Date;\n\n  private _renderId = 1;\n\n  private _throttleGetLogbookEntries = throttle(\n    () => this._getLogBookData(),\n    10000\n  );\n\n  protected render(): TemplateResult {\n    if (!isComponentLoaded(this.hass, \"logbook\")) {\n      return html``;\n    }\n\n    if (this._error) {\n      return html`<div class=\"no-entries\">\n        ${`${this.hass.localize(\"ui.components.logbook.retrieval_error\")}: ${\n          this._error\n        }`}\n      </div>`;\n    }\n\n    if (this._logbookEntries === undefined) {\n      return html`\n        <div class=\"progress-wrapper\">\n          <ha-circular-progress\n            active\n            alt=${this.hass.localize(\"ui.common.loading\")}\n          ></ha-circular-progress>\n        </div>\n      `;\n    }\n\n    if (this._logbookEntries.length === 0) {\n      return html`<div class=\"no-entries\">\n        ${this.hass.localize(\"ui.components.logbook.entries_not_found\")}\n      </div>`;\n    }\n\n    return html`\n      <ha-logbook-renderer\n        .hass=${this.hass}\n        .narrow=${this.narrow}\n        .virtualize=${this.virtualize}\n        .noIcon=${this.noIcon}\n        .noName=${this.noName}\n        .relativeTime=${this.relativeTime}\n        .entries=${this._logbookEntries}\n        .traceContexts=${this._traceContexts}\n        .userIdToName=${this._userIdToName}\n      ></ha-logbook-renderer>\n    `;\n  }\n\n  public async refresh(force = false) {\n    if (!force && this._logbookEntries === undefined) {\n      return;\n    }\n\n    this._throttleGetLogbookEntries.cancel();\n    this._updateTraceContexts.cancel();\n    this._updateUsers.cancel();\n\n    if (\"range\" in this.time) {\n      clearLogbookCache(\n        this.time.range[0].toISOString(),\n        this.time.range[1].toISOString()\n      );\n    }\n\n    this._lastLogbookDate = undefined;\n    this._logbookEntries = undefined;\n    this._throttleGetLogbookEntries();\n  }\n\n  protected updated(changedProps: PropertyValues): void {\n    super.updated(changedProps);\n\n    let changed = changedProps.has(\"time\");\n\n    for (const key of [\"entityIds\", \"deviceIds\"]) {\n      if (!changedProps.has(key)) {\n        continue;\n      }\n\n      const oldValue = changedProps.get(key) as string[] | undefined;\n      const curValue = this[key] as string[] | undefined;\n\n      if (\n        !oldValue ||\n        !curValue ||\n        oldValue.length !== curValue.length ||\n        !oldValue.every((val) => curValue.includes(val))\n      ) {\n        changed = true;\n        break;\n      }\n    }\n\n    if (changed) {\n      this.refresh(true);\n      return;\n    }\n\n    if (this._filterAlwaysEmptyResults) {\n      return;\n    }\n\n    // We only need to fetch again if we track recent entries for an entity\n    if (\n      !(\"recent\" in this.time) ||\n      !changedProps.has(\"hass\") ||\n      !this.entityIds\n    ) {\n      return;\n    }\n\n    const oldHass = changedProps.get(\"hass\") as HomeAssistant | undefined;\n\n    // Refresh data if we know the entity has changed.\n    if (\n      !oldHass ||\n      ensureArray(this.entityIds).some(\n        (entityId) => this.hass.states[entityId] !== oldHass?.states[entityId]\n      )\n    ) {\n      // wait for commit of data (we only account for the default setting of 1 sec)\n      setTimeout(this._throttleGetLogbookEntries, 1000);\n    }\n  }\n\n  private get _filterAlwaysEmptyResults(): boolean {\n    const entityIds = ensureArray(this.entityIds);\n    const deviceIds = ensureArray(this.deviceIds);\n\n    // If all specified filters are empty lists, we can return an empty list.\n    return (\n      (entityIds || deviceIds) &&\n      (!entityIds || entityIds.length === 0) &&\n      (!deviceIds || deviceIds.length === 0)\n    );\n  }\n\n  private async _getLogBookData() {\n    this._renderId += 1;\n    const renderId = this._renderId;\n    this._error = undefined;\n\n    if (this._filterAlwaysEmptyResults) {\n      this._logbookEntries = [];\n      this._lastLogbookDate = undefined;\n      return;\n    }\n\n    this._updateUsers();\n    if (this.hass.user?.is_admin) {\n      this._updateTraceContexts();\n    }\n\n    let startTime: Date;\n    let endTime: Date;\n    let purgeBeforePythonTime: number | undefined;\n\n    if (\"range\" in this.time) {\n      [startTime, endTime] = this.time.range;\n    } else if (\"recent\" in this.time) {\n      purgeBeforePythonTime =\n        new Date(new Date().getTime() - this.time.recent * 1000).getTime() /\n        1000;\n      startTime =\n        this._lastLogbookDate || new Date(purgeBeforePythonTime * 1000);\n      endTime = new Date();\n    } else {\n      throw new Error(\"Unexpected time specified\");\n    }\n\n    let newEntries: LogbookEntry[];\n\n    try {\n      newEntries = await getLogbookData(\n        this.hass,\n        startTime.toISOString(),\n        endTime.toISOString(),\n        ensureArray(this.entityIds),\n        ensureArray(this.deviceIds)\n      );\n    } catch (err: any) {\n      if (renderId === this._renderId) {\n        this._error = err.message;\n      }\n      return;\n    }\n\n    // New render happening.\n    if (renderId !== this._renderId) {\n      return;\n    }\n\n    // Put newest ones on top. Reverse works in-place so\n    // make a copy first.\n    newEntries = [...newEntries].reverse();\n\n    this._logbookEntries =\n      // If we have a purgeBeforeTime, it means we're in recent-mode and fetch batches\n      purgeBeforePythonTime && this._logbookEntries\n        ? newEntries.concat(\n            ...this._logbookEntries.filter(\n              (entry) => entry.when > purgeBeforePythonTime!\n            )\n          )\n        : newEntries;\n    this._lastLogbookDate = endTime;\n  }\n\n  private _updateTraceContexts = throttle(async () => {\n    this._traceContexts = await loadTraceContexts(this.hass);\n  }, 60000);\n\n  private _updateUsers = throttle(async () => {\n    const userIdToName = {};\n\n    // Start loading users\n    const userProm = this.hass.user?.is_admin && fetchUsers(this.hass);\n\n    // Process persons\n    for (const entity of Object.values(this.hass.states)) {\n      if (\n        entity.attributes.user_id &&\n        computeStateDomain(entity) === \"person\"\n      ) {\n        userIdToName[entity.attributes.user_id] =\n          entity.attributes.friendly_name;\n      }\n    }\n\n    // Process users\n    if (userProm) {\n      const users = await userProm;\n      for (const user of users) {\n        if (!(user.id in userIdToName)) {\n          userIdToName[user.id] = user.name;\n        }\n      }\n    }\n\n    this._userIdToName = userIdToName;\n  }, 60000);\n\n  static get styles() {\n    return [\n      css`\n        :host {\n          display: block;\n        }\n\n        :host([virtualize]) {\n          height: 100%;\n        }\n\n        .no-entries {\n          text-align: center;\n          padding: 16px;\n          color: var(--secondary-text-color);\n        }\n\n        .progress-wrapper {\n          display: flex;\n          justify-content: center;\n          height: 100%;\n          align-items: center;\n        }\n      `,\n    ];\n  }\n}\n\ndeclare global {\n  interface HTMLElementTagNameMap {\n    \"ha-logbook\": HaLogbook;\n  }\n}\n"],"names":[],"sourceRoot":""}