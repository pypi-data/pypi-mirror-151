# -*- coding: utf-8 -*-
from setuptools import setup

package_dir = \
{'': 'src'}

packages = \
['theovib']

package_data = \
{'': ['*']}

install_requires = \
['numpy>=1.22.0,<2.0.0']

setup_kwargs = {
    'name': 'theovib',
    'version': '0.0.1',
    'description': 'Tools for molecular vibrations analysis',
    'long_description': '# Theovib\n[![GitHub issues](https://img.shields.io/github/issues/ljduarte/theovib)](https://github.com/ljduarte/theovib/issues)\n[![GitHub forks](https://img.shields.io/github/forks/ljduarte/theovib)](https://github.com/ljduarte/theovib/network)\n[![GitHub stars](https://img.shields.io/github/stars/ljduarte/theovib)](https://github.com/ljduarte/theovib/stargazers)\n[![GitHub license](https://img.shields.io/github/license/ljduarte/theovib)](https://github.com/ljduarte/theovib/blob/main/LICENSE)\n\n:construction: Version 0.0.1 :construction:\n\nA package for molecular vibrations analysis. This initial version contains functions to solve the vibrational problem starting from the Hessian matrix or from a 3D-Hessian construct from Interacting Quantum Atoms energy decomposition scheme. \nInfrared intensities are obtained from atomic charges and dipoles obtained by AIMAll.   \n\n## Contents\n[Installation](#Installation)\n\n[Usage](#Usage)\n\n[Theory](#theory)\n\n[Contributing](#Contributing)\n\n[Documentation](#Documentation)\n\n[License](#License)\n\n## Installation\n\nTo install, just use pip:\n\n```bash\n$ pip install theovib\n```\n\n## Usage\n\nYou can perform a vibrational analysis for water using the files in the **"example"** folder.\n\n### Vibrational analysis of the Water molecule\n\nIn **./example/h2o** you will find all single point calculations needed to generate the 3D-Hessian matrix.\n\nThe Cartesian coordinates of the water molecule are:\n\n| **Atom(Label)** |    **X** |     **Y** |     **Z** |\n|-----------------|---------:|----------:|----------:|\n| O(1)            | 0.000000 |  0.000000 |  0.004316 |\n| H(2)            | 0.000000 | -0.763369 | -0.580667 |\n| H(3)            | 0.000000 |  0.763369 | -0.580667 |\n\nThe internal coordinates are defined as:\n\n* **bond** between atoms **1** and **2**;\n* **bond** between atoms **1** and **3**;\n* **angle** defined by atoms **1**, **2** and **3**.\n\nWe start writing the input file:\n\n```bash\nMOLECULE:\nh2o\nFOLDER:\nh2o\nDELTA:\n0.05\nBOND:\n1 2\n1 3\n---\nANGLE:\n2 1 3\n---\n```\n\n**DELTA** is the displacement that generated the non-equilibrium geometries.\n\n#### 1. Reading the input file:\n\nImport modules:\n\n```python\n from theovib.molecule import *\n from theovib.internal import *\n from theovib.matrices import *\n from theovib.ir import *\n from theovib.input import *\n```\n\nUse the **Input** class:\n\n```python\ninput_data = Input.read_text(\'input.txt\')\n```\n\nUse the **Molecule** class and its methods to get and store data:\n\n```python\nmolecule = Molecule.read_gaussian(input_data.folder + \'/EQ.com\')\nmolecule.energy = get_energy_from_wfn(input_data.folder +\'/EQ.wfn\')\nmolecule.iqa_energy = get_IQA(input_data.folder +\'/EQ_atomicfiles\', molecule.atoms)\n```\n\n#### 2. Construct the B matrix:\n\nInitialize and construct the **B** matrix:\n\n```python\nb_matrix = []\n    for coord in input_data.bond:\n        b_matrix.append(bond(molecule.positions, coord[0], coord[1]))\n    for coord in input_data.angle:\n        b_matrix.append(angle(molecule.positions, coord[0], coord[1], coord[2]))\nmolecule.b_matrix = np.array(b_matrix)    \n```\n\n#### 3. Obtain the Hessian and 3D Hessian matrix:\n\n```python   \nmolecule.hessian, molecule.iqa_hessian, errors = hessian_from_iqa(molecule.atoms, input_data.delta, input_data.folder)\n```\n\nThe Hessian and 3D Hessian are numerrically generated using IQA contributions from AIMAll outputs\n\n#### 3. Calculate the normal coordinates and infrared intensities:\n\n```python\nmolecule.normal_coordinates, molecule.freq, molecule.iqa_freq, molecule.iqa_terms = normal_modes(molecule.atoms, molecule.iqa_hessian)\nmolecule.int, molecule.c_tensors, molecule.ct_tensors, molecule.dp_tensors = intensities(molecule.atoms, molecule.positions, molecule.normal_coordinates, input_data.folder, input_data.delta)\n```\n\n#### 4. Convert to internal coordinates to obtain the force constants:\n\n```python\nmolecule.internal_hessian, molecule.iqa_forces = convert_to_internal(molecule.atoms, molecule.b_matrix, molecule.iqa_hessian)\n```\n\n## Theory\n#### 1. Force constant in internal coordinates:\n\nIn order to calculate, and decompose the force constants into its IQA components, one needs first to convert the Cartesian Hessian into the the Wilson\'s $\\mathbf{F}$ matrix, that contains the force constants, and their interactions, expressed in internal coordinates. To do this, it is necessary to define the $\\mathbf{B}$ matrix, that converts the $N\\times 3N$ Cartesian coordinates matrix, $\\mathbf{X}$ in the internal coordinates matrix $\\mathbf{R}$:\n\n$$ \\mathbf{B}\\mathbf{X} = \\mathbf{R} $$\n\nThe process of setting-up the $\\mathbf{B}$ matrix is tedious and can be found in the literature. \nWe start by calculating the pseudo-inverse of $\\mathbf{B}$ by:\n\n$$ \\mathbf{B}^{-1} =\\mathbf{M}^{2} \\mathbf{B}^{\\dagger}\\mathbf{G}^{-1} $$\n\n$\\mathbf{G}$ contains the inverse of the kinetic energy terms and its inverse, $\\mathbf{G}^{-1}$, is given by:\n\n$$\\mathbf{G}^{-1} =\\mathbf{D} \\mathbf{\\Phi}^{-1}\\mathbf{D}^{\\dagger}$$\n\nwhere $\\mathbf{D}$ and $\\mathbf{\\Phi}$ are, respectively, the eigenvectors and the diagonal eigenvalues matrices of $\\mathbf{G}$. The force constants in internal coordinates are then obtained as follows:\n\n$$\\mathbf{F} ={\\mathbf{B}^{\\dagger}}^{-1} \\mathbf{H}\\mathbf{B}^{-1}$$   \n\nThe decomposition of the force constants into the IQA contributions is done using:\n\n$$\\left[\\sum_{k=1}^{N^2} \\mathbf{F^{IQA}_k}\\right] ={\\mathbf{B}^{\\dagger}}^{-1} \\left[\\sum_{k=1}^{N^2} \\mathbf{H^{IQA}_k}\\right] \\mathbf{B}^{-1}$$\n\nEach $F^{IQA}_k$ is a matrix containing the contribution of the $k^{th}$ IQA term of $\\mathbf{F}$. \n\n#### 2. Infrared intensities:\n\nThe infrared intensity, $A_k$, of normal mode $Q_k$ is defined as:\n\n$$A_k = \\frac{N_A \\pi}{3c^2}\\left(\\frac{\\mathrm{d}\\vec{p}}{\\mathrm{d}Q_k}\\right)^2 = \\frac{N_A \\pi}{3c^2} \\sum_{i=1}^3 \\left( \\frac{\\partial\\vec{p}}{\\partial \\sigma_i} \\cdot \\frac{\\partial\\sigma_i}{\\partial Q_k}\\right)^2$$\n\nwhere $N_A$ is the Avogadro\'s constant, $c$ is the speed of light and $\\vec{p}$ is the molecular dipole moment. The derivative $\\frac{\\partial\\sigma_i}{\\partial Q_k}$ is a element of the $k^{th}$ column of $\\mathbf{L}$.\n\n$$\\mathbf{L} = \\mathbf{M}\\mathbf{A}$$\n\nLet $\\mathbf{T}$  be a block-diagonal matrix of dimension $3N \\times 3N$ where each $3 \\times 3$ block is an atomic polar tensor. The dipole moment derivative of normal mode $Q_k$ is obtained by solving:\n\n$$\\frac{\\mathrm{d}p}{\\mathrm{d}Q_k} = \\mathbf{U} \\cdot \\mathbf{T} \\cdot \\mathbf{L_k}$$\n$\\mathbf{L_k}$ is the $k^{th}$ column of $\\mathbf{L}$. $\\mathbf{U}$ is a $1 \\times N$  line vector whose elements equals 1. \n\n## Contributing\n\nInterested in contributing? Check out the contributing guidelines. Please note that this project is released with a Code of Conduct. By contributing to this project, you agree to abide by its terms.\n\n## Documentation\nhttps://ljduarte.github.io/theovib/\n\n## License\n\n`theovib` was created by L. J. Duarte. It is licensed under the terms of the MIT license.\n\n## Credits\n\n`theovib` was created with [`cookiecutter`](https://cookiecutter.readthedocs.io/en/latest/) and the `py-pkgs-cookiecutter` [template](https://github.com/py-pkgs/py-pkgs-cookiecutter).\n',
    'author': 'L. J. Duarte',
    'author_email': None,
    'maintainer': None,
    'maintainer_email': None,
    'url': None,
    'package_dir': package_dir,
    'packages': packages,
    'package_data': package_data,
    'install_requires': install_requires,
    'python_requires': '>=3.8,<4.0',
}


setup(**setup_kwargs)
