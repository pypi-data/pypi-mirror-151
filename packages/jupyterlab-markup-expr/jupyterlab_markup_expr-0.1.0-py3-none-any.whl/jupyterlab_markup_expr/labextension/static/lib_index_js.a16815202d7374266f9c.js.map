{"version":3,"file":"lib_index_js.a16815202d7374266f9c.js","mappings":";;;;;;;;;;;;;;;;AAA4C;AACyB;AACrE;AACA;AACA;AACA;AACA,eAAe,mFAAsB;AACrC;AACA;AACA;AACA,yBAAyB;AACzB;AACA,gBAAgB,qDAAgB;AAChC;AACA,CAAC;AACD,iEAAe,MAAM,EAAC;;;;;;;;;;;;;;;;ACff;AACA;AACP;AACA,qIAAqI;AACrI,uIAAuI;AACvI;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","sources":["webpack://jupyterlab-markup-expr/./lib/index.js","webpack://jupyterlab-markup-expr/./lib/plugin.js"],"sourcesContent":["import { expressionPlugin } from './plugin';\nimport { simpleMarkdownItPlugin } from '@agoose77/jupyterlab-markup';\nconst PACKAGE_NS = '@agoose77/jupyterlab-markup-expr';\n/**\n * Captures expressions as data-attributes\n */\nconst plugin = simpleMarkdownItPlugin(PACKAGE_NS, {\n    id: 'markdown-it-expr',\n    title: 'Create spans with stored expressions from Markdown',\n    description: 'Embed Markdown text in a data attribute in rendered spans',\n    documentationUrls: {},\n    plugin: async () => {\n        return [expressionPlugin];\n    }\n});\nexport default plugin;\n","export const EXPR_CLASS = 'eval-expr';\nexport function expressionPlugin(md, options) {\n    var _a, _b;\n    const openDelim = (_a = options === null || options === void 0 ? void 0 : options.openDelim) !== null && _a !== void 0 ? _a : '{{';\n    const closeDelim = (_b = options === null || options === void 0 ? void 0 : options.closeDelim) !== null && _b !== void 0 ? _b : '}}';\n    function tokenize(state, silent) {\n        // Check we start with the correct markers\n        let pos = state.pos;\n        // For performance, just check first character\n        if (state.src[pos] !== openDelim[0]) {\n            return false;\n        }\n        // Does the full substring match?\n        if (state.src.slice(pos, pos + openDelim.length) !== openDelim) {\n            return false;\n        }\n        pos += openDelim.length;\n        // First index _after_ {{\n        const startPos = pos;\n        // Find end marker }}\n        let stopPos = -1;\n        while (stopPos === -1) {\n            // Find first character of end marker\n            pos = state.src.indexOf(closeDelim[0], pos);\n            // Didn't find character\n            if (pos === -1) {\n                return false;\n            }\n            // If subsequent tokens don't match, just advance by one token!\n            if (state.src.slice(pos, pos + closeDelim.length) !== closeDelim) {\n                pos++;\n                continue;\n            }\n            stopPos = pos;\n            pos += closeDelim.length;\n        }\n        // Read tokens inside of the bracket\n        const expression = state.src.slice(startPos, stopPos);\n        state.pos = pos;\n        const exprToken = state.push('expr', 'input', 0);\n        exprToken.attrSet('type', 'hidden');\n        exprToken.attrSet('class', EXPR_CLASS);\n        exprToken.attrSet('value', expression);\n        return true;\n    }\n    md.inline.ruler.after('emphasis', 'expr', tokenize);\n}\n"],"names":[],"sourceRoot":""}