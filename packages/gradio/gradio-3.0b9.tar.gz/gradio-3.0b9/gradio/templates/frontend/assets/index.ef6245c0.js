import{S as H,i as Y,s as Z,d as y,v as J,a as Q,b as g,c as S,e as j,f as R,n as C,g as P,y as X,ak as re,h as O,N as V,I as te,x as Qt,o as st,J as it,af as _t,al as rt,a2 as ee,l as G,r as wt,w as F,aj as Vt,D as k,G as ce,E,H as le,u as xt,B as T,C as U,F as D,t as Se,q as tt,L as bt,M as pt,k as ge,m as Te,P as $t,X as Ue,Q as en,R as vt,T as tn,K as De,U as nn,V as on}from"./index.f59195be.js";import{B as Pe}from"./BlockLabel.5f51ff82.js";import{C as at,i as ct,I as lt,W as yt}from"./Image.svelte_svelte_type_style_lang.d7ab3a12.js";import{f as Le}from"./index.ae6ab930.js";import{I as Xe,C as kt,M as It}from"./ModifyUpload.bbdfb820.js";import{U as Et}from"./Upload.1c1a427b.js";import{B as St}from"./Block.e518fe00.js";import{E as zn}from"./Image.e1aa5cfc.js";import"./_commonjsHelpers.88e99c8f.js";import"./styles.d87a390f.js";const ut="mnt/c/Users/islam/dev/gradio-repos/gradio/ui/packages/icons/src/Sketch.svelte";function Ae(n){let e,t;const s={c:function(){e=Q("svg"),t=Q("path"),g(t,"d","M17 3a2.828 2.828 0 1 1 4 4L7.5 20.5 2 22l1.5-5.5L17 3z"),S(t,ut,11,2,230),g(e,"xmlns","http://www.w3.org/2000/svg"),g(e,"width","100%"),g(e,"height","100%"),g(e,"viewBox","0 0 24 24"),g(e,"fill","none"),g(e,"stroke","currentColor"),g(e,"stroke-width","1.5"),g(e,"stroke-linecap","round"),g(e,"stroke-linejoin","round"),g(e,"class","feather feather-edit-2"),S(e,ut,0,0,0)},l:function(o){throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option")},m:function(o,a){j(o,e,a),R(e,t)},p:C,i:C,o:C,d:function(o){o&&P(e)}};return y("SvelteRegisterBlock",{block:s,id:Ae.name,type:"component",source:"",ctx:n}),s}function sn(n,e){let{$$slots:t={},$$scope:s}=e;J("Sketch",t,[]);const i=[];return Object.keys(e).forEach(o=>{!~i.indexOf(o)&&o.slice(0,2)!=="$$"&&o!=="slot"&&console.warn(`<Sketch> was created with unknown prop '${o}'`)}),[]}class Fe extends H{constructor(e){super(e),Y(this,e,sn,Ae,Z,{}),y("SvelteRegisterComponent",{component:this,tagName:"Sketch",options:e,id:Ae.name})}}const Ne="mnt/c/Users/islam/dev/gradio-repos/gradio/ui/packages/icons/src/Undo.svelte";function qe(n){let e,t,s;const i={c:function(){e=Q("svg"),t=Q("polyline"),s=Q("path"),g(t,"points","1 4 1 10 7 10"),S(t,Ne,11,2,234),g(s,"d","M3.51 15a9 9 0 1 0 2.13-9.36L1 10"),S(s,Ne,11,37,269),g(e,"xmlns","http://www.w3.org/2000/svg"),g(e,"width","100%"),g(e,"height","100%"),g(e,"viewBox","0 0 24 24"),g(e,"fill","none"),g(e,"stroke","currentColor"),g(e,"stroke-width","1.5"),g(e,"stroke-linecap","round"),g(e,"stroke-linejoin","round"),g(e,"class","feather feather-rotate-ccw"),S(e,Ne,0,0,0)},l:function(a){throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option")},m:function(a,c){j(a,e,c),R(e,t),R(e,s)},p:C,i:C,o:C,d:function(a){a&&P(e)}};return y("SvelteRegisterBlock",{block:i,id:qe.name,type:"component",source:"",ctx:n}),i}function rn(n,e){let{$$slots:t={},$$scope:s}=e;J("Undo",t,[]);const i=[];return Object.keys(e).forEach(o=>{!~i.indexOf(o)&&o.slice(0,2)!=="$$"&&o!=="slot"&&console.warn(`<Undo> was created with unknown prop '${o}'`)}),[]}class jt extends H{constructor(e){super(e),Y(this,e,rn,qe,Z,{}),y("SvelteRegisterComponent",{component:this,tagName:"Undo",options:e,id:qe.name})}}const je="mnt/c/Users/islam/dev/gradio-repos/gradio/ui/packages/icons/src/Image.svelte";function We(n){let e,t,s,i;const o={c:function(){e=Q("svg"),t=Q("rect"),s=Q("circle"),i=Q("polyline"),g(t,"x","3"),g(t,"y","3"),g(t,"width","18"),g(t,"height","18"),g(t,"rx","2"),g(t,"ry","2"),S(t,je,11,2,229),g(s,"cx","8.5"),g(s,"cy","8.5"),g(s,"r","1.5"),S(s,je,11,59,286),g(i,"points","21 15 16 10 5 21"),S(i,je,15,3,329),g(e,"xmlns","http://www.w3.org/2000/svg"),g(e,"width","100%"),g(e,"height","100%"),g(e,"viewBox","0 0 24 24"),g(e,"fill","none"),g(e,"stroke","currentColor"),g(e,"stroke-width","1.5"),g(e,"stroke-linecap","round"),g(e,"stroke-linejoin","round"),g(e,"class","feather feather-image"),S(e,je,0,0,0)},l:function(c){throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option")},m:function(c,u){j(c,e,u),R(e,t),R(e,s),R(e,i)},p:C,i:C,o:C,d:function(c){c&&P(e)}};return y("SvelteRegisterBlock",{block:o,id:We.name,type:"component",source:"",ctx:n}),o}function an(n,e){let{$$slots:t={},$$scope:s}=e;J("Image",t,[]);const i=[];return Object.keys(e).forEach(o=>{!~i.indexOf(o)&&o.slice(0,2)!=="$$"&&o!=="slot"&&console.warn(`<Image> was created with unknown prop '${o}'`)}),[]}class ae extends H{constructor(e){super(e),Y(this,e,an,We,Z,{}),y("SvelteRegisterComponent",{component:this,tagName:"Image",options:e,id:We.name})}}const cn="mnt/c/Users/islam/dev/gradio-repos/gradio/ui/packages/image/src/Cropper.svelte";function Ge(n){let e,t;const s={c:function(){e=O("img"),V(e.src,t=n[0])||g(e,"src",t),g(e,"alt",""),S(e,cn,20,0,503)},l:function(o){throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option")},m:function(o,a){j(o,e,a),n[2](e)},p:function(o,[a]){a&1&&!V(e.src,t=o[0])&&g(e,"src",t)},i:C,o:C,d:function(o){o&&P(e),n[2](null)}};return y("SvelteRegisterBlock",{block:s,id:Ge.name,type:"component",source:"",ctx:n}),s}function ln(n,e,t){let{$$slots:s={},$$scope:i}=e;J("Cropper",s,[]);let{image:o}=e,a;const c=X();re(()=>{const l=new at(a,{autoCropArea:1,cropend(){const m=l.getCroppedCanvas().toDataURL();c("crop",m)}});return c("crop",o),()=>{l.destroy()}});const u=["image"];Object.keys(e).forEach(l=>{!~u.indexOf(l)&&l.slice(0,2)!=="$$"&&l!=="slot"&&console.warn(`<Cropper> was created with unknown prop '${l}'`)});function d(l){te[l?"unshift":"push"](()=>{a=l,t(1,a)})}return n.$$set=l=>{"image"in l&&t(0,o=l.image)},n.$capture_state=()=>({Cropper:at,onMount:re,createEventDispatcher:X,image:o,el:a,dispatch:c}),n.$inject_state=l=>{"image"in l&&t(0,o=l.image),"el"in l&&t(1,a=l.el)},e&&"$$inject"in e&&n.$inject_state(e.$$inject),[o,a,d]}class Pt extends H{constructor(e){super(e),Y(this,e,ln,Ge,Z,{image:0}),y("SvelteRegisterComponent",{component:this,tagName:"Cropper_1",options:e,id:Ge.name});const{ctx:t}=this.$$,s=e.props||{};t[0]===void 0&&!("image"in s)&&console.warn("<Cropper> was created without expected prop 'image'")}get image(){throw new Error("<Cropper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'")}set image(e){throw new Error("<Cropper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'")}}class ft{constructor(e,t){this.x=e,this.y=t}}class dt extends ft{update(e){this.x=e.x,this.y=e.y}moveByAngle(e,t){const s=e+Math.PI/2;this.x=this.x+Math.sin(s)*t,this.y=this.y-Math.cos(s)*t}equalsTo(e){return this.x===e.x&&this.y===e.y}getDifferenceTo(e){return new ft(this.x-e.x,this.y-e.y)}getDistanceTo(e){const t=this.getDifferenceTo(e);return Math.sqrt(Math.pow(t.x,2)+Math.pow(t.y,2))}getAngleTo(e){const t=this.getDifferenceTo(e);return Math.atan2(t.y,t.x)}toObject(){return{x:this.x,y:this.y}}}const un=30;class ht{constructor({radius:e=un,enabled:t=!0,initialPoint:s={x:0,y:0}}={}){this.radius=e,this._isEnabled=t,this.pointer=new dt(s.x,s.y),this.brush=new dt(s.x,s.y),this.angle=0,this.distance=0,this._hasMoved=!1}enable(){this._isEnabled=!0}disable(){this._isEnabled=!1}isEnabled(){return this._isEnabled}setRadius(e){this.radius=e}getRadius(){return this.radius}getBrushCoordinates(){return this.brush.toObject()}getPointerCoordinates(){return this.pointer.toObject()}getBrush(){return this.brush}getPointer(){return this.pointer}getAngle(){return this.angle}getDistance(){return this.distance}brushHasMoved(){return this._hasMoved}update(e,{both:t=!1}={}){return this._hasMoved=!1,this.pointer.equalsTo(e)&&!t?!1:(this.pointer.update(e),t?(this._hasMoved=!0,this.brush.update(e),!0):(this._isEnabled?(this.distance=this.pointer.getDistanceTo(this.brush),this.angle=this.pointer.getAngleTo(this.brush),this.distance>this.radius&&(this.brush.moveByAngle(this.angle,this.distance-this.radius),this._hasMoved=!0)):(this.distance=0,this.angle=0,this.brush.update(e),this._hasMoved=!0),!0))}}const{Error:ie,Object:fn}=Qt,nt="mnt/c/Users/islam/dev/gradio-repos/gradio/ui/packages/image/src/Sketch.svelte";function mt(n,e,t){const s=n.slice();return s[44]=e[t].name,s[45]=e[t].zIndex,s[46]=e,s[47]=t,s}function He(n){let e,t,s;const i={c:function(){e=O("div"),e.textContent="Start drawing",g(e,"class","absolute inset-0 flex items-center justify-center z-40 pointer-events-none touch-none text-gray-400 md:text-xl"),S(e,nt,346,2,8073)},m:function(a,c){j(a,e,c),s=!0},i:function(a){s||(_t(()=>{t||(t=rt(e,Le,{duration:50},!0)),t.run(1)}),s=!0)},o:function(a){t||(t=rt(e,Le,{duration:50},!1)),t.run(0),s=!1},d:function(a){a&&P(e),a&&t&&t.end()}};return y("SvelteRegisterBlock",{block:i,id:He.name,type:"if",source:"(346:1) {#if line_count === 0}",ctx:n}),i}function Ye(n){let e,t=n[44],s,i;const o=()=>n[14](e,t),a=()=>n[14](null,t),c={c:function(){e=O("canvas"),g(e,"key",n[44]),ee(e,"display","block"),ee(e,"position","absolute"),ee(e,"z-index",n[45]),ee(e,"width",n[0]+"px"),ee(e,"height",n[1]+"px"),S(e,nt,354,2,8319)},m:function(d,l){j(d,e,l),o(),s||(i=[G(e,"mousedown",n[44]==="interface"?n[6]:void 0,!1,!1,!1),G(e,"mousemove",n[44]==="interface"?n[7]:void 0,!1,!1,!1),G(e,"mouseup",n[44]==="interface"?n[8]:void 0,!1,!1,!1),G(e,"mouseout",n[44]==="interface"?n[8]:void 0,!1,!1,!1),G(e,"touchstart",n[44]==="interface"?n[6]:void 0,!1,!1,!1),G(e,"touchmove",n[44]==="interface"?n[7]:void 0,!1,!1,!1),G(e,"touchend",n[44]==="interface"?n[8]:void 0,!1,!1,!1),G(e,"touchcancel",n[44]==="interface"?n[8]:void 0,!1,!1,!1)],s=!0)},p:function(d,l){n=d,l[0]&1&&ee(e,"width",n[0]+"px"),l[0]&2&&ee(e,"height",n[1]+"px"),t!==n[44]&&(a(),t=n[44],o())},d:function(d){d&&P(e),a(),s=!1,wt(i)}};return y("SvelteRegisterBlock",{block:c,id:Ye.name,type:"each",source:"(354:1) {#each canvas_types as { name, zIndex }}",ctx:n}),c}function Ze(n){let e,t,s,i,o=n[4]===0&&He(n),a=n[5];st(a);let c=[];for(let d=0;d<a.length;d+=1)c[d]=Ye(mt(n,a,d));const u={c:function(){e=O("div"),o&&o.c(),t=F();for(let l=0;l<c.length;l+=1)c[l].c();g(e,"class","touch-none relative h-full w-full"),_t(()=>n[16].call(e)),S(e,nt,339,0,7899)},l:function(l){throw new ie("options.hydrate only works if the component was compiled with the `hydratable: true` option")},m:function(l,m){j(l,e,m),o&&o.m(e,null),R(e,t);for(let f=0;f<c.length;f+=1)c[f].m(e,null);n[15](e),s=Vt(e,n[16].bind(e)),i=!0},p:function(l,m){if(l[4]===0?o?m[0]&16&&k(o,1):(o=He(l),o.c(),k(o,1),o.m(e,t)):o&&(ce(),E(o,1,1,()=>{o=null}),le()),m[0]&487){a=l[5],st(a);let f;for(f=0;f<a.length;f+=1){const w=mt(l,a,f);c[f]?c[f].p(w,m):(c[f]=Ye(w),c[f].c(),c[f].m(e,null))}for(;f<c.length;f+=1)c[f].d(1);c.length=a.length}},i:function(l){i||(k(o),i=!0)},o:function(l){E(o),i=!1},d:function(l){l&&P(e),o&&o.d(),xt(c,l),n[15](null),s()}};return y("SvelteRegisterBlock",{block:u,id:Ze.name,type:"component",source:"",ctx:n}),u}function gt(n,e){return{x:n.x+(e.x-n.x)/2,y:n.y+(e.y-n.y)/2}}function dn(n,e,t){let{$$slots:s={},$$scope:i}=e;J("Sketch",s,[]);const o=X();let{value:a}=e,c,u=50,d="#090f1f",l="#aaa",m=400,f=400;const w=[{name:"interface",zIndex:15},{name:"drawing",zIndex:11},{name:"temp",zIndex:12}];let h={},p={},M=[],z=[],L=!0,N=!0,q=!1,W=!1,_=null,x=null,K=null,$=null,ne="",b=0;re(()=>{Object.keys(h).forEach(r=>{p[r]=h[r].getContext("2d")}),_=new ht({radius:u/1.5,enabled:!0,initialPoint:{x:window.innerWidth/2,y:window.innerHeight/2}}),x=u,$=new ct((r,v)=>Oe(r,v)),$.observe(K),de(),t(13,c=!0),window.setTimeout(()=>{const r=window.innerWidth/2,v=window.innerHeight/2;_.update({x:r-x/4,y:v},{both:!0}),_.update({x:r+x/4,y:v},{both:!1}),L=!0,N=!0,oe(),ne&&be(ne)},100)}),it(()=>{t(13,c=!1),$.unobserve(K)});function ot(){const r=z.slice(0,-1);oe(),ue({lines:r}),t(4,b=z.length),Ee()}let Re=()=>JSON.stringify({lines:z,width:m,height:f}),be=r=>{if(typeof r!="string")throw new Error("save_data needs to be of type string!");const{lines:v,width:I,height:B}=JSON.parse(r);if(!v||typeof v.push!="function")throw new Error("save_data.lines needs to be an array!");if(oe(),I===m&&B===f)ue({lines:v});else{const A=m/I,se=f/B;ue({lines:v.map(he=>({...he,points:he.points.map(me=>({x:me.x*A,y:me.y*se})),brush_radius:he.brush_radius}))})}},ue=({lines:r})=>{r.forEach(v=>{const{points:I,brush_color:B,brush_radius:A}=v;ke({points:I,brush_color:B,brush_radius:A}),M=I,Ie({brush_color:B,brush_radius:A})})},Ce=r=>{r.preventDefault(),W=!0;const{x:v,y:I}=ve(r);r.touches&&r.touches.length>0&&_.update({x:v,y:I},{both:!0}),ye(v,I),t(4,b+=1)},pe=r=>{r.preventDefault();const{x:v,y:I}=ve(r);ye(v,I)},Be=r=>{r.preventDefault(),pe(r),q=!1,W=!1,Ie()},Oe=r=>{const v=Re();for(const I of r){const{width:B,height:A}=I.contentRect;fe(h.interface,B,A),fe(h.drawing,B,A),fe(h.temp,B,A),de({once:!0})}be(v,!0)},fe=(r,v,I)=>{r.width=v*3,r.height=I*3,r.style.width=v,r.style.height=I},ve=r=>{const v=h.interface.getBoundingClientRect();let I=r.clientX,B=r.clientY;return r.changedTouches&&r.changedTouches.length>0&&(I=r.changedTouches[0].clientX,B=r.changedTouches[0].clientY),{x:I-v.left,y:B-v.top}},ye=(r,v)=>{_.update({x:r*3,y:v*3});const I=!_.isEnabled();(W&&!q||I&&W)&&(q=!0,M.push(_.brush.toObject())),q&&(M.push(_.brush.toObject()),ke({points:M,brush_color:d,brush_radius:u})),L=!0},ke=({points:r,brush_color:v,brush_radius:I})=>{p.temp.lineJoin="round",p.temp.lineCap="round",p.temp.strokeStyle=v,p.temp.clearRect(0,0,p.temp.canvas.width,p.temp.canvas.height),p.temp.lineWidth=I;let B=r[0],A=r[1];p.temp.moveTo(A.x,A.y),p.temp.beginPath();for(var se=1,he=r.length;se<he;se++){var me=gt(B,A);p.temp.quadraticCurveTo(B.x,B.y,me.x,me.y),B=r[se],A=r[se+1]}p.temp.lineTo(B.x,B.y),p.temp.stroke()},Ie=()=>{if(M.length<2)return;z.push({points:[...M],brush_color:d,brush_radius:u}),M.length=0;const r=h.temp.width,v=h.temp.height;p.drawing.drawImage(h.temp,0,0,r,v),p.temp.clearRect(0,0,r,v),Ee()},Ee=()=>{o("change",ze())};function oe(){z=[],N=!0,p.drawing.clearRect(0,0,h.drawing.width,h.drawing.height),p.temp.clearRect(0,0,h.temp.width,h.temp.height),p.drawing.fillStyle="#FFFFFF",p.drawing.fillRect(0,0,h.drawing.width,h.drawing.height),t(4,b=0)}let de=({once:r=!1}={})=>{if(L||N){const v=_.getPointerCoordinates(),I=_.getBrushCoordinates();Me(p.interface,v,I),L=!1,N=!1}r||window.requestAnimationFrame(()=>{de()})},Me=(r,v,I)=>{r.clearRect(0,0,r.canvas.width,r.canvas.height),r.beginPath(),r.fillStyle=d,r.arc(I.x,I.y,u/2,0,Math.PI*2,!0),r.fill(),r.beginPath(),r.fillStyle=l,r.arc(v.x,v.y,4,0,Math.PI*2,!0),r.fill(),_.isEnabled()&&(r.beginPath(),r.lineWidth=2,r.lineCap="round",r.setLineDash([2,4]),r.strokeStyle=l,r.stroke()),r.beginPath(),r.fillStyle=l,r.arc(I.x,I.y,2,0,Math.PI*2,!0),r.fill()};function ze(){return h.drawing.toDataURL("image/png")}const Yt=["value"];fn.keys(e).forEach(r=>{!~Yt.indexOf(r)&&r.slice(0,2)!=="$$"&&r!=="slot"&&console.warn(`<Sketch> was created with unknown prop '${r}'`)});function Zt(r,v){te[r?"unshift":"push"](()=>{h[v]=r,t(2,h)})}function Jt(r){te[r?"unshift":"push"](()=>{K=r,t(3,K)})}function Kt(){m=this.offsetWidth,f=this.offsetHeight,t(0,m),t(1,f)}return n.$$set=r=>{"value"in r&&t(9,a=r.value)},n.$capture_state=()=>({onMount:re,onDestroy:it,createEventDispatcher:X,fade:Le,LazyBrush:ht,ResizeObserver:ct,dispatch:o,value:a,mounted:c,brush_radius:u,brush_color:d,catenary_color:l,canvas_width:m,canvas_height:f,mid_point:gt,canvas_types:w,canvas:h,ctx:p,points:M,lines:z,mouse_has_moved:L,values_changed:N,is_drawing:q,is_pressing:W,lazy:_,chain_length:x,canvas_container:K,canvas_observer:$,save_data:ne,line_count:b,undo:ot,get_save_data:Re,load_save_data:be,draw_lines:ue,handle_draw_start:Ce,handle_draw_move:pe,handle_draw_end:Be,handle_canvas_resize:Oe,set_canvas_size:fe,get_pointer_pos:ve,handle_pointer_move:ye,draw_points:ke,saveLine:Ie,trigger_on_change:Ee,clear:oe,loop:de,draw_interface:Me,get_image_data:ze}),n.$inject_state=r=>{"value"in r&&t(9,a=r.value),"mounted"in r&&t(13,c=r.mounted),"brush_radius"in r&&(u=r.brush_radius),"brush_color"in r&&(d=r.brush_color),"catenary_color"in r&&(l=r.catenary_color),"canvas_width"in r&&t(0,m=r.canvas_width),"canvas_height"in r&&t(1,f=r.canvas_height),"canvas"in r&&t(2,h=r.canvas),"ctx"in r&&(p=r.ctx),"points"in r&&(M=r.points),"lines"in r&&(z=r.lines),"mouse_has_moved"in r&&(L=r.mouse_has_moved),"values_changed"in r&&(N=r.values_changed),"is_drawing"in r&&(q=r.is_drawing),"is_pressing"in r&&(W=r.is_pressing),"lazy"in r&&(_=r.lazy),"chain_length"in r&&(x=r.chain_length),"canvas_container"in r&&t(3,K=r.canvas_container),"canvas_observer"in r&&($=r.canvas_observer),"save_data"in r&&(ne=r.save_data),"line_count"in r&&t(4,b=r.line_count),"get_save_data"in r&&(Re=r.get_save_data),"load_save_data"in r&&(be=r.load_save_data),"draw_lines"in r&&(ue=r.draw_lines),"handle_draw_start"in r&&t(6,Ce=r.handle_draw_start),"handle_draw_move"in r&&t(7,pe=r.handle_draw_move),"handle_draw_end"in r&&t(8,Be=r.handle_draw_end),"handle_canvas_resize"in r&&(Oe=r.handle_canvas_resize),"set_canvas_size"in r&&(fe=r.set_canvas_size),"get_pointer_pos"in r&&(ve=r.get_pointer_pos),"handle_pointer_move"in r&&(ye=r.handle_pointer_move),"draw_points"in r&&(ke=r.draw_points),"saveLine"in r&&(Ie=r.saveLine),"trigger_on_change"in r&&(Ee=r.trigger_on_change),"loop"in r&&(de=r.loop),"draw_interface"in r&&(Me=r.draw_interface)},e&&"$$inject"in e&&n.$inject_state(e.$$inject),n.$$.update=()=>{n.$$.dirty[0]&8704&&c&&!a&&oe()},[m,f,h,K,b,w,Ce,pe,Be,a,ot,oe,ze,c,Zt,Jt,Kt]}class Rt extends H{constructor(e){super(e),Y(this,e,dn,Ze,Z,{value:9,undo:10,clear:11,get_image_data:12},null,[-1,-1]),y("SvelteRegisterComponent",{component:this,tagName:"Sketch",options:e,id:Ze.name});const{ctx:t}=this.$$,s=e.props||{};t[9]===void 0&&!("value"in s)&&console.warn("<Sketch> was created without expected prop 'value'")}get value(){throw new ie("<Sketch>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'")}set value(e){throw new ie("<Sketch>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'")}get undo(){return this.$$.ctx[10]}set undo(e){throw new ie("<Sketch>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'")}get clear(){return this.$$.ctx[11]}set clear(e){throw new ie("<Sketch>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'")}get get_image_data(){return this.$$.ctx[12]}set get_image_data(e){throw new ie("<Sketch>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'")}}const hn="mnt/c/Users/islam/dev/gradio-repos/gradio/ui/packages/image/src/ModifySketch.svelte";function Je(n){let e,t,s,i,o;t=new Xe({props:{Icon:jt},$$inline:!0}),t.$on("click",n[1]),i=new Xe({props:{Icon:kt},$$inline:!0}),i.$on("click",n[2]);const a={c:function(){e=O("div"),T(t.$$.fragment),s=F(),T(i.$$.fragment),g(e,"class","z-50 top-2 right-2 justify-end flex gap-1 absolute"),S(e,hn,6,0,208)},l:function(u){throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option")},m:function(u,d){j(u,e,d),U(t,e,null),R(e,s),U(i,e,null),o=!0},p:C,i:function(u){o||(k(t.$$.fragment,u),k(i.$$.fragment,u),o=!0)},o:function(u){E(t.$$.fragment,u),E(i.$$.fragment,u),o=!1},d:function(u){u&&P(e),D(t),D(i)}};return y("SvelteRegisterBlock",{block:a,id:Je.name,type:"component",source:"",ctx:n}),a}function mn(n,e,t){let{$$slots:s={},$$scope:i}=e;J("ModifySketch",s,[]);const o=X(),a=[];Object.keys(e).forEach(d=>{!~a.indexOf(d)&&d.slice(0,2)!=="$$"&&d!=="slot"&&console.warn(`<ModifySketch> was created with unknown prop '${d}'`)});const c=()=>o("undo"),u=()=>o("clear");return n.$capture_state=()=>({createEventDispatcher:X,IconButton:Xe,Undo:jt,Clear:kt,dispatch:o}),[o,c,u]}class Ct extends H{constructor(e){super(e),Y(this,e,mn,Je,Z,{}),y("SvelteRegisterComponent",{component:this,tagName:"ModifySketch",options:e,id:Je.name})}}const _e="mnt/c/Users/islam/dev/gradio-repos/gradio/ui/packages/image/src/ImageEditor.svelte";function Ke(n){let e,t,s,i,o,a,c,u,d;const l={c:function(){e=O("div"),t=O("div"),s=O("button"),s.textContent="Save",i=F(),o=O("button"),o.textContent="Cancel",a=F(),c=O("div"),S(s,_e,35,2,925),S(o,_e,36,2,1003),g(t,"class","image_editor_buttons"),S(t,_e,34,1,888),S(c,_e,38,1,1072),g(e,"class","fixed w-screen h-screen top-0 left-0 bg-black bg-opacity-50 z-40 flex flex-col justify-center items-center"),S(e,_e,31,0,764)},l:function(f){throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option")},m:function(f,w){j(f,e,w),R(e,t),R(t,s),R(t,i),R(t,o),R(e,a),R(e,c),n[6](c),u||(d=[G(s,"click",n[4],!1,!1,!1),G(o,"click",n[5],!1,!1,!1)],u=!0)},p:C,i:C,o:C,d:function(f){f&&P(e),n[6](null),u=!1,wt(d)}};return y("SvelteRegisterBlock",{block:l,id:Ke.name,type:"component",source:"",ctx:n}),l}function gn(n,e,t){let{$$slots:s={},$$scope:i}=e;J("ImageEditor",s,[]);let{value:o}=e,a,c;const u=X();function d(){t(1,c=new lt(a,{usageStatistics:!1,includeUI:{loadImage:{path:o,name:"Edit Image"},menuBarPosition:"left",uiSize:{width:"800px",height:"600px"}},cssMaxWidth:700,cssMaxHeight:500,selectionStyle:{cornerSize:20,rotatingPointOffset:70}}))}re(d);const l=["value"];Object.keys(e).forEach(h=>{!~l.indexOf(h)&&h.slice(0,2)!=="$$"&&h!=="slot"&&console.warn(`<ImageEditor> was created with unknown prop '${h}'`)});const m=()=>u("save",c.toDataURL()),f=()=>u("cancel");function w(h){te[h?"unshift":"push"](()=>{a=h,t(0,a)})}return n.$$set=h=>{"value"in h&&t(3,o=h.value)},n.$capture_state=()=>({ImageEditor:lt,createEventDispatcher:X,onMount:re,value:o,el:a,editor:c,dispatch:u,create_editor:d}),n.$inject_state=h=>{"value"in h&&t(3,o=h.value),"el"in h&&t(0,a=h.el),"editor"in h&&t(1,c=h.editor)},e&&"$$inject"in e&&n.$inject_state(e.$$inject),[a,c,u,o,m,f,w]}class Bt extends H{constructor(e){super(e),Y(this,e,gn,Ke,Z,{value:3}),y("SvelteRegisterComponent",{component:this,tagName:"ImageEditor_1",options:e,id:Ke.name});const{ctx:t}=this.$$,s=e.props||{};t[3]===void 0&&!("value"in s)&&console.warn("<ImageEditor> was created without expected prop 'value'")}get value(){throw new Error("<ImageEditor>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'")}set value(e){throw new Error("<ImageEditor>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'")}}const we="mnt/c/Users/islam/dev/gradio-repos/gradio/ui/packages/image/src/Image.svelte";function Ot(n){let e,t;const s={c:function(){e=O("img"),g(e,"class","w-full h-full object-contain s-jgfuGbX8tZTu"),V(e.src,t=n[0])||g(e,"src",t),g(e,"alt",""),S(e,we,85,2,2311)},m:function(o,a){j(o,e,a)},p:function(o,a){a&1&&!V(e.src,t=o[0])&&g(e,"src",t)},i:C,o:C,d:function(o){o&&P(e)}};return y("SvelteRegisterBlock",{block:s,id:Ot.name,type:"else",source:"(85:1) {:else}",ctx:n}),s}function Mt(n){let e,t,s,i,o,a,c=n[9]==="edit"&&Qe(n);t=new It({props:{editable:!0},$$inline:!0}),t.$on("edit",n[19]),t.$on("clear",n[12]);const u={c:function(){c&&c.c(),e=F(),T(t.$$.fragment),s=F(),i=O("img"),g(i,"class","w-full h-full object-contain s-jgfuGbX8tZTu"),V(i.src,o=n[0])||g(i,"src",o),g(i,"alt",""),S(i,we,83,2,2236)},m:function(l,m){c&&c.m(l,m),j(l,e,m),U(t,l,m),j(l,s,m),j(l,i,m),a=!0},p:function(l,m){l[9]==="edit"?c?(c.p(l,m),m&512&&k(c,1)):(c=Qe(l),c.c(),k(c,1),c.m(e.parentNode,e)):c&&(ce(),E(c,1,1,()=>{c=null}),le()),(!a||m&1&&!V(i.src,o=l[0]))&&g(i,"src",o)},i:function(l){a||(k(c),k(t.$$.fragment,l),a=!0)},o:function(l){E(c),E(t.$$.fragment,l),a=!1},d:function(l){c&&c.d(l),l&&P(e),D(t,l),l&&P(s),l&&P(i)}};return y("SvelteRegisterBlock",{block:u,id:Mt.name,type:"if",source:"(70:29) ",ctx:n}),u}function zt(n){let e,t;e=new Pt({props:{image:n[0]},$$inline:!0}),e.$on("crop",n[13]);const s={c:function(){T(e.$$.fragment)},m:function(o,a){U(e,o,a),t=!0},p:function(o,a){const c={};a&1&&(c.image=o[0]),e.$set(c)},i:function(o){t||(k(e.$$.fragment,o),t=!0)},o:function(o){E(e.$$.fragment,o),t=!1},d:function(o){D(e,o)}};return y("SvelteRegisterBlock",{block:s,id:zt.name,type:"if",source:"(68:29) ",ctx:n}),s}function Tt(n){let e,t,s,i;const o=[Nt,Dt],a=[];function c(d,l){return d[3]==="upload"?0:d[3]==="webcam"?1:-1}~(e=c(n))&&(t=a[e]=o[e](n));const u={c:function(){t&&t.c(),s=tt()},m:function(l,m){~e&&a[e].m(l,m),j(l,s,m),i=!0},p:function(l,m){let f=e;e=c(l),e===f?~e&&a[e].p(l,m):(t&&(ce(),E(a[f],1,1,()=>{a[f]=null}),le()),~e?(t=a[e],t?t.p(l,m):(t=a[e]=o[e](l),t.c()),k(t,1),t.m(s.parentNode,s)):t=null)},i:function(l){i||(k(t),i=!0)},o:function(l){E(t),i=!1},d:function(l){~e&&a[e].d(l),l&&P(s)}};return y("SvelteRegisterBlock",{block:u,id:Tt.name,type:"if",source:"(51:26) ",ctx:n}),u}function Ut(n){let e,t,s,i;e=new Ct({$$inline:!0}),e.$on("undo",n[14]),e.$on("clear",n[15]);let o={value:n[0]};s=new Rt({props:o,$$inline:!0}),n[16](s),s.$on("change",n[13]);const a={c:function(){T(e.$$.fragment),t=F(),T(s.$$.fragment)},m:function(u,d){U(e,u,d),j(u,t,d),U(s,u,d),i=!0},p:function(u,d){const l={};d&1&&(l.value=u[0]),s.$set(l)},i:function(u){i||(k(e.$$.fragment,u),k(s.$$.fragment,u),i=!0)},o:function(u){E(e.$$.fragment,u),E(s.$$.fragment,u),i=!1},d:function(u){D(e,u),u&&P(t),n[16](null),D(s,u)}};return y("SvelteRegisterBlock",{block:a,id:Ut.name,type:"if",source:'(45:1) {#if source === \\"canvas\\"}',ctx:n}),a}function Qe(n){let e,t;e=new Bt({props:{value:n[0]},$$inline:!0}),e.$on("cancel",n[18]),e.$on("save",n[13]);const s={c:function(){T(e.$$.fragment)},m:function(o,a){U(e,o,a),t=!0},p:function(o,a){const c={};a&1&&(c.value=o[0]),e.$set(c)},i:function(o){t||(k(e.$$.fragment,o),t=!0)},o:function(o){E(e.$$.fragment,o),t=!1},d:function(o){D(e,o)}};return y("SvelteRegisterBlock",{block:s,id:Qe.name,type:"if",source:'(71:2) {#if mode === \\"edit\\"}',ctx:n}),s}function Dt(n){let e,t;e=new yt({$$inline:!0}),e.$on("capture",n[13]);const s={c:function(){T(e.$$.fragment)},m:function(o,a){U(e,o,a),t=!0},p:C,i:function(o){t||(k(e.$$.fragment,o),t=!0)},o:function(o){E(e.$$.fragment,o),t=!1},d:function(o){D(e,o)}};return y("SvelteRegisterBlock",{block:s,id:Dt.name,type:"if",source:"(65:32) ",ctx:n}),s}function Nt(n){let e,t,s;function i(c){n[17](c)}let o={filetype:"image/x-png,image/gif,image/jpeg",include_file_metadata:!1,$$slots:{default:[Lt]},$$scope:{ctx:n}};n[8]!==void 0&&(o.dragging=n[8]),e=new Et({props:o,$$inline:!0}),te.push(()=>bt(e,"dragging",i)),e.$on("load",n[11]);const a={c:function(){T(e.$$.fragment)},m:function(u,d){U(e,u,d),s=!0},p:function(u,d){const l={};d&2097376&&(l.$$scope={dirty:d,ctx:u}),!t&&d&256&&(t=!0,l.dragging=u[8],pt(()=>t=!1)),e.$set(l)},i:function(u){s||(k(e.$$.fragment,u),s=!0)},o:function(u){E(e.$$.fragment,u),s=!1},d:function(u){D(e,u)}};return y("SvelteRegisterBlock",{block:a,id:Nt.name,type:"if",source:'(52:2) {#if source === \\"upload\\"}',ctx:n}),a}function Lt(n){let e,t,s,i,o,a,c,u,d;const l={c:function(){e=O("div"),t=ge(n[5]),s=F(),i=O("span"),o=ge("- "),a=ge(n[6]),c=ge(" -"),u=F(),d=ge(n[7]),g(i,"class","text-gray-300 s-jgfuGbX8tZTu"),S(i,we,60,5,1726),g(e,"class","flex flex-col s-jgfuGbX8tZTu"),S(e,we,58,4,1676)},m:function(f,w){j(f,e,w),R(e,t),R(e,s),R(e,i),R(i,o),R(i,a),R(i,c),R(e,u),R(e,d)},p:function(f,w){w&32&&Te(t,f[5]),w&64&&Te(a,f[6]),w&128&&Te(d,f[7])},d:function(f){f&&P(e)}};return y("SvelteRegisterBlock",{block:l,id:Lt.name,type:"slot",source:'(53:3) <Upload     bind:dragging     filetype=\\"image/x-png,image/gif,image/jpeg\\"     on:load={handle_upload}     include_file_metadata={false}    >',ctx:n}),l}function Ve(n){let e,t,s,i,o,a;e=new Pe({props:{show_label:n[2],Icon:n[3]==="canvas"?Fe:ae,label:n[1]||(n[3]==="canvas"?"Sketch":"Image")},$$inline:!0});const c=[Ut,Tt,zt,Mt,Ot],u=[];function d(m,f){return m[3]==="canvas"?0:m[0]===null?1:m[4]==="select"?2:m[4]==="editor"?3:4}i=d(n),o=u[i]=c[i](n);const l={c:function(){T(e.$$.fragment),t=F(),s=O("div"),o.c(),g(s,"class","s-jgfuGbX8tZTu"),Se(s,"bg-gray-200",n[0]),Se(s,"h-60",n[3]!=="webcam"),S(s,we,43,0,1228)},l:function(f){throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option")},m:function(f,w){U(e,f,w),j(f,t,w),j(f,s,w),u[i].m(s,null),a=!0},p:function(f,[w]){const h={};w&4&&(h.show_label=f[2]),w&8&&(h.Icon=f[3]==="canvas"?Fe:ae),w&10&&(h.label=f[1]||(f[3]==="canvas"?"Sketch":"Image")),e.$set(h);let p=i;i=d(f),i===p?u[i].p(f,w):(ce(),E(u[p],1,1,()=>{u[p]=null}),le(),o=u[i],o?o.p(f,w):(o=u[i]=c[i](f),o.c()),k(o,1),o.m(s,null)),w&1&&Se(s,"bg-gray-200",f[0]),w&8&&Se(s,"h-60",f[3]!=="webcam")},i:function(f){a||(k(e.$$.fragment,f),k(o),a=!0)},o:function(f){E(e.$$.fragment,f),E(o),a=!1},d:function(f){D(e,f),f&&P(t),f&&P(s),u[i].d()}};return y("SvelteRegisterBlock",{block:l,id:Ve.name,type:"component",source:"",ctx:n}),l}function _n(n,e,t){let{$$slots:s={},$$scope:i}=e;J("Image",s,[]);let{value:o}=e,{label:a=void 0}=e,{show_label:c}=e,{source:u="upload"}=e,{tool:d="editor"}=e,{drop_text:l="Drop an image file"}=e,{or_text:m="or"}=e,{upload_text:f="click to upload"}=e,w="view",h;function p({detail:b}){t(0,o=b)}function M({detail:b}){t(0,o=null),L("clear")}function z({detail:b}){t(0,o=b),t(9,w="view"),L("edit")}const L=X();let N=!1;const q=["value","label","show_label","source","tool","drop_text","or_text","upload_text"];Object.keys(e).forEach(b=>{!~q.indexOf(b)&&b.slice(0,2)!=="$$"&&b!=="slot"&&console.warn(`<Image> was created with unknown prop '${b}'`)});const W=()=>h.undo(),_=()=>h.clear();function x(b){te[b?"unshift":"push"](()=>{h=b,t(10,h)})}function K(b){N=b,t(8,N)}const $=()=>t(9,w="view"),ne=()=>t(9,w="edit");return n.$$set=b=>{"value"in b&&t(0,o=b.value),"label"in b&&t(1,a=b.label),"show_label"in b&&t(2,c=b.show_label),"source"in b&&t(3,u=b.source),"tool"in b&&t(4,d=b.tool),"drop_text"in b&&t(5,l=b.drop_text),"or_text"in b&&t(6,m=b.or_text),"upload_text"in b&&t(7,f=b.upload_text)},n.$capture_state=()=>({createEventDispatcher:X,BlockLabel:Pe,Image:ae,SketchIcon:Fe,Cropper:Pt,Sketch:Rt,Webcam:yt,ModifySketch:Ct,ImageEditor:Bt,Upload:Et,ModifyUpload:It,value:o,label:a,show_label:c,source:u,tool:d,drop_text:l,or_text:m,upload_text:f,mode:w,sketch:h,handle_upload:p,handle_clear:M,handle_save:z,dispatch:L,dragging:N}),n.$inject_state=b=>{"value"in b&&t(0,o=b.value),"label"in b&&t(1,a=b.label),"show_label"in b&&t(2,c=b.show_label),"source"in b&&t(3,u=b.source),"tool"in b&&t(4,d=b.tool),"drop_text"in b&&t(5,l=b.drop_text),"or_text"in b&&t(6,m=b.or_text),"upload_text"in b&&t(7,f=b.upload_text),"mode"in b&&t(9,w=b.mode),"sketch"in b&&t(10,h=b.sketch),"dragging"in b&&t(8,N=b.dragging)},e&&"$$inject"in e&&n.$inject_state(e.$$inject),n.$$.update=()=>{n.$$.dirty&1&&L("change",o),n.$$.dirty&256&&L("drag",N)},[o,a,c,u,d,l,m,f,N,w,h,p,M,z,W,_,x,K,$,ne]}class Xt extends H{constructor(e){super(e),Y(this,e,_n,Ve,Z,{value:0,label:1,show_label:2,source:3,tool:4,drop_text:5,or_text:6,upload_text:7}),y("SvelteRegisterComponent",{component:this,tagName:"Image_1",options:e,id:Ve.name});const{ctx:t}=this.$$,s=e.props||{};t[0]===void 0&&!("value"in s)&&console.warn("<Image> was created without expected prop 'value'"),t[2]===void 0&&!("show_label"in s)&&console.warn("<Image> was created without expected prop 'show_label'")}get value(){throw new Error("<Image>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'")}set value(e){throw new Error("<Image>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'")}get label(){throw new Error("<Image>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'")}set label(e){throw new Error("<Image>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'")}get show_label(){throw new Error("<Image>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'")}set show_label(e){throw new Error("<Image>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'")}get source(){throw new Error("<Image>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'")}set source(e){throw new Error("<Image>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'")}get tool(){throw new Error("<Image>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'")}set tool(e){throw new Error("<Image>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'")}get drop_text(){throw new Error("<Image>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'")}set drop_text(e){throw new Error("<Image>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'")}get or_text(){throw new Error("<Image>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'")}set or_text(e){throw new Error("<Image>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'")}get upload_text(){throw new Error("<Image>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'")}set upload_text(e){throw new Error("<Image>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'")}}const xe="mnt/c/Users/islam/dev/gradio-repos/gradio/ui/packages/image/src/StaticImage.svelte";function At(n){let e,t;const s={c:function(){e=O("img"),g(e,"class","w-full h-full object-contain"),V(e.src,t=n[0])||g(e,"src",t),g(e,"alt",""),S(e,xe,16,1,547)},m:function(o,a){j(o,e,a)},p:function(o,a){a&1&&!V(e.src,t=o[0])&&g(e,"src",t)},i:C,o:C,d:function(o){o&&P(e)}};return y("SvelteRegisterBlock",{block:s,id:At.name,type:"else",source:"(16:0) {:else}",ctx:n}),s}function Ft(n){let e,t,s,i;s=new ae({$$inline:!0});const o={c:function(){e=O("div"),t=O("div"),T(s.$$.fragment),g(t,"class","h-5 dark:text-white opacity-50"),S(t,xe,13,2,470),g(e,"class","h-full min-h-[15rem] flex justify-center items-center"),S(e,xe,12,1,400)},m:function(c,u){j(c,e,u),R(e,t),U(s,t,null),i=!0},p:C,i:function(c){i||(k(s.$$.fragment,c),i=!0)},o:function(c){E(s.$$.fragment,c),i=!1},d:function(c){c&&P(e),D(s)}};return y("SvelteRegisterBlock",{block:o,id:Ft.name,type:"if",source:"(12:0) {#if value === null}",ctx:n}),o}function $e(n){let e,t,s,i,o,a;e=new Pe({props:{show_label:n[2],Icon:ae,label:n[1]||"Image"},$$inline:!0});const c=[Ft,At],u=[];function d(m,f){return m[0]===null?0:1}s=d(n),i=u[s]=c[s](n);const l={c:function(){T(e.$$.fragment),t=F(),i.c(),o=tt()},l:function(f){throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option")},m:function(f,w){U(e,f,w),j(f,t,w),u[s].m(f,w),j(f,o,w),a=!0},p:function(f,[w]){const h={};w&4&&(h.show_label=f[2]),w&2&&(h.label=f[1]||"Image"),e.$set(h);let p=s;s=d(f),s===p?u[s].p(f,w):(ce(),E(u[p],1,1,()=>{u[p]=null}),le(),i=u[s],i?i.p(f,w):(i=u[s]=c[s](f),i.c()),k(i,1),i.m(o.parentNode,o))},i:function(f){a||(k(e.$$.fragment,f),k(i),a=!0)},o:function(f){E(e.$$.fragment,f),E(i),a=!1},d:function(f){D(e,f),f&&P(t),u[s].d(f),f&&P(o)}};return y("SvelteRegisterBlock",{block:l,id:$e.name,type:"component",source:"",ctx:n}),l}function wn(n,e,t){let{$$slots:s={},$$scope:i}=e;J("StaticImage",s,[]);let{value:o}=e,{label:a=void 0}=e,{show_label:c}=e;const u=X(),d=["value","label","show_label"];return Object.keys(e).forEach(l=>{!~d.indexOf(l)&&l.slice(0,2)!=="$$"&&l!=="slot"&&console.warn(`<StaticImage> was created with unknown prop '${l}'`)}),n.$$set=l=>{"value"in l&&t(0,o=l.value),"label"in l&&t(1,a=l.label),"show_label"in l&&t(2,c=l.show_label)},n.$capture_state=()=>({createEventDispatcher:X,BlockLabel:Pe,Image:ae,value:o,label:a,show_label:c,dispatch:u}),n.$inject_state=l=>{"value"in l&&t(0,o=l.value),"label"in l&&t(1,a=l.label),"show_label"in l&&t(2,c=l.show_label)},e&&"$$inject"in e&&n.$inject_state(e.$$inject),n.$$.update=()=>{n.$$.dirty&1&&o&&u("change",o)},[o,a,c]}class qt extends H{constructor(e){super(e),Y(this,e,wn,$e,Z,{value:0,label:1,show_label:2}),y("SvelteRegisterComponent",{component:this,tagName:"StaticImage",options:e,id:$e.name});const{ctx:t}=this.$$,s=e.props||{};t[0]===void 0&&!("value"in s)&&console.warn("<StaticImage> was created without expected prop 'value'"),t[2]===void 0&&!("show_label"in s)&&console.warn("<StaticImage> was created without expected prop 'show_label'")}get value(){throw new Error("<StaticImage>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'")}set value(e){throw new Error("<StaticImage>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'")}get label(){throw new Error("<StaticImage>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'")}set label(e){throw new Error("<StaticImage>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'")}get show_label(){throw new Error("<StaticImage>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'")}set show_label(e){throw new Error("<StaticImage>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'")}}function Wt(n){let e,t,s;function i(c){n[10](c)}let o={source:n[2],tool:n[3],label:n[4],show_label:n[5],drop_text:n[9]("interface.drop_image"),or_text:n[9]("or"),upload_text:n[9]("interface.click_to_upload")};n[0]!==void 0&&(o.value=n[0]),e=new Xt({props:o,$$inline:!0}),te.push(()=>bt(e,"value",i)),e.$on("edit",n[11]),e.$on("clear",n[12]),e.$on("change",n[13]),e.$on("drag",n[14]);const a={c:function(){T(e.$$.fragment)},m:function(u,d){U(e,u,d),s=!0},p:function(u,d){const l={};d&4&&(l.source=u[2]),d&8&&(l.tool=u[3]),d&16&&(l.label=u[4]),d&32&&(l.show_label=u[5]),d&512&&(l.drop_text=u[9]("interface.drop_image")),d&512&&(l.or_text=u[9]("or")),d&512&&(l.upload_text=u[9]("interface.click_to_upload")),!t&&d&1&&(t=!0,l.value=u[0],pt(()=>t=!1)),e.$set(l)},i:function(u){s||(k(e.$$.fragment,u),s=!0)},o:function(u){E(e.$$.fragment,u),s=!1},d:function(u){D(e,u)}};return y("SvelteRegisterBlock",{block:a,id:Wt.name,type:"else",source:"(30:1) {:else}",ctx:n}),a}function Gt(n){let e,t;e=new qt({props:{value:n[0],label:n[4],show_label:n[5]},$$inline:!0});const s={c:function(){T(e.$$.fragment)},m:function(o,a){U(e,o,a),t=!0},p:function(o,a){const c={};a&1&&(c.value=o[0]),a&16&&(c.label=o[4]),a&32&&(c.show_label=o[5]),e.$set(c)},i:function(o){t||(k(e.$$.fragment,o),t=!0)},o:function(o){E(e.$$.fragment,o),t=!1},d:function(o){D(e,o)}};return y("SvelteRegisterBlock",{block:s,id:Gt.name,type:"if",source:'(28:1) {#if mode === \\"static\\"}',ctx:n}),s}function Ht(n){let e,t,s,i,o,a;const c=[n[6]];let u={};for(let w=0;w<c.length;w+=1)u=tn(u,c[w]);e=new vt({props:u,$$inline:!0});const d=[Gt,Wt],l=[];function m(w,h){return w[7]==="static"?0:1}s=m(n),i=l[s]=d[s](n);const f={c:function(){T(e.$$.fragment),t=F(),i.c(),o=tt()},m:function(h,p){U(e,h,p),j(h,t,p),l[s].m(h,p),j(h,o,p),a=!0},p:function(h,p){const M=p&64?nn(c,[on(h[6])]):{};e.$set(M);let z=s;s=m(h),s===z?l[s].p(h,p):(ce(),E(l[z],1,1,()=>{l[z]=null}),le(),i=l[s],i?i.p(h,p):(i=l[s]=d[s](h),i.c()),k(i,1),i.m(o.parentNode,o))},i:function(h){a||(k(e.$$.fragment,h),k(i),a=!0)},o:function(h){E(e.$$.fragment,h),E(i),a=!1},d:function(h){D(e,h),h&&P(t),l[s].d(h),h&&P(o)}};return y("SvelteRegisterBlock",{block:f,id:Ht.name,type:"slot",source:'(19:0) <Block  variant={mode === \\"dynamic\\" && value === null && source === \\"upload\\"   ? \\"dashed\\"   : \\"solid\\"}  color={dragging ? \\"green\\" : \\"grey\\"}  padding={false}  {elem_id} >',ctx:n}),f}function et(n){let e,t;e=new St({props:{variant:n[7]==="dynamic"&&n[0]===null&&n[2]==="upload"?"dashed":"solid",color:n[8]?"green":"grey",padding:!1,elem_id:n[1],$$slots:{default:[Ht]},$$scope:{ctx:n}},$$inline:!0});const s={c:function(){T(e.$$.fragment)},l:function(o){throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option")},m:function(o,a){U(e,o,a),t=!0},p:function(o,[a]){const c={};a&133&&(c.variant=o[7]==="dynamic"&&o[0]===null&&o[2]==="upload"?"dashed":"solid"),a&256&&(c.color=o[8]?"green":"grey"),a&2&&(c.elem_id=o[1]),a&66557&&(c.$$scope={dirty:a,ctx:o}),e.$set(c)},i:function(o){t||(k(e.$$.fragment,o),t=!0)},o:function(o){E(e.$$.fragment,o),t=!1},d:function(o){D(e,o)}};return y("SvelteRegisterBlock",{block:s,id:et.name,type:"component",source:"",ctx:n}),s}function bn(n,e,t){let s;$t(Ue,"_"),en(n,Ue,_=>t(9,s=_));let{$$slots:i={},$$scope:o}=e;J("Image",i,[]);let{elem_id:a=""}=e,{value:c=null}=e,{source:u="upload"}=e,{tool:d="editor"}=e,{label:l}=e,{show_label:m}=e,{loading_status:f}=e,{mode:w}=e;const h=X();let p;const M=["elem_id","value","source","tool","label","show_label","loading_status","mode"];Object.keys(e).forEach(_=>{!~M.indexOf(_)&&_.slice(0,2)!=="$$"&&_!=="slot"&&console.warn(`<Image> was created with unknown prop '${_}'`)});function z(_){c=_,t(0,c)}function L(_){De.call(this,n,_)}function N(_){De.call(this,n,_)}function q(_){De.call(this,n,_)}const W=({detail:_})=>t(8,p=_);return n.$$set=_=>{"elem_id"in _&&t(1,a=_.elem_id),"value"in _&&t(0,c=_.value),"source"in _&&t(2,u=_.source),"tool"in _&&t(3,d=_.tool),"label"in _&&t(4,l=_.label),"show_label"in _&&t(5,m=_.show_label),"loading_status"in _&&t(6,f=_.loading_status),"mode"in _&&t(7,w=_.mode)},n.$capture_state=()=>({createEventDispatcher:X,Image:Xt,StaticImage:qt,Block:St,_:Ue,StatusTracker:vt,elem_id:a,value:c,source:u,tool:d,label:l,show_label:m,loading_status:f,mode:w,dispatch:h,dragging:p,$_:s}),n.$inject_state=_=>{"elem_id"in _&&t(1,a=_.elem_id),"value"in _&&t(0,c=_.value),"source"in _&&t(2,u=_.source),"tool"in _&&t(3,d=_.tool),"label"in _&&t(4,l=_.label),"show_label"in _&&t(5,m=_.show_label),"loading_status"in _&&t(6,f=_.loading_status),"mode"in _&&t(7,w=_.mode),"dragging"in _&&t(8,p=_.dragging)},e&&"$$inject"in e&&n.$inject_state(e.$$inject),n.$$.update=()=>{n.$$.dirty&1&&h("change")},[c,a,u,d,l,m,f,w,p,s,z,L,N,q,W]}class pn extends H{constructor(e){super(e),Y(this,e,bn,et,Z,{elem_id:1,value:0,source:2,tool:3,label:4,show_label:5,loading_status:6,mode:7}),y("SvelteRegisterComponent",{component:this,tagName:"Image_1",options:e,id:et.name});const{ctx:t}=this.$$,s=e.props||{};t[4]===void 0&&!("label"in s)&&console.warn("<Image> was created without expected prop 'label'"),t[5]===void 0&&!("show_label"in s)&&console.warn("<Image> was created without expected prop 'show_label'"),t[6]===void 0&&!("loading_status"in s)&&console.warn("<Image> was created without expected prop 'loading_status'"),t[7]===void 0&&!("mode"in s)&&console.warn("<Image> was created without expected prop 'mode'")}get elem_id(){throw new Error("<Image>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'")}set elem_id(e){throw new Error("<Image>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'")}get value(){throw new Error("<Image>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'")}set value(e){throw new Error("<Image>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'")}get source(){throw new Error("<Image>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'")}set source(e){throw new Error("<Image>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'")}get tool(){throw new Error("<Image>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'")}set tool(e){throw new Error("<Image>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'")}get label(){throw new Error("<Image>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'")}set label(e){throw new Error("<Image>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'")}get show_label(){throw new Error("<Image>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'")}set show_label(e){throw new Error("<Image>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'")}get loading_status(){throw new Error("<Image>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'")}set loading_status(e){throw new Error("<Image>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'")}get mode(){throw new Error("<Image>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'")}set mode(e){throw new Error("<Image>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'")}}var Cn=pn;const Bn=["static","dynamic"];export{Cn as Component,zn as ExampleComponent,Bn as modes};
