{"version":3,"sources":["circle-to-polygon.tsx","index.tsx"],"names":["earthRadius","toRadians","angleInDegrees","Math","PI","toDegrees","angleInRadians","offset","c1","distance","bearing","lat1","lon1","dByR","lat","asin","sin","cos","atan2","map","Streamlit","events","addEventListener","RENDER_EVENT","event","data","detail","fig","args","height","width","debouncedUpdateComponentValue","debounce","updateComponentValue","global_data","__GLOBAL_DATA__","bounds","getBounds","zoom","getZoom","setComponentValue","last_clicked","lat_lng_clicked","last_object_clicked","all_drawings","last_active_drawing","last_circle_radius","last_circle_polygon","onDraw","e","type","layerType","layer","center","_latlng","lng","radius","options","polygon","sides","coordinates","i","push","circleToPolygon","onLayerClick","latlng","details","toGeoJSON","drawn_items","features","map_div","document","getElementById","map_div2","style","indexOf","a","createElement","href","id","innerHTML","body","appendChild","render_script","replaced","key","on","_layers","setFrameHeight","setComponentReady"],"mappings":"8IAAMA,EAAc,QAEpB,SAASC,EAAUC,GACf,OAAQA,EAAiBC,KAAKC,GAAM,IAGxC,SAASC,EAAUC,GACf,OAAyB,IAAjBA,EAAwBH,KAAKC,GAGzC,SAASG,EACLC,EACAC,EACAT,EACAU,GACA,IAAIC,EAAOV,EAAUO,EAAG,IACpBI,EAAOX,EAAUO,EAAG,IACpBK,EAAOJ,EAAWT,EAClBc,EAAMX,KAAKY,KACXZ,KAAKa,IAAIL,GAAQR,KAAKc,IAAIJ,GAAQV,KAAKc,IAAIN,GAAQR,KAAKa,IAAIH,GAAQV,KAAKc,IAAIP,IAQjF,MAAO,CAACL,EALJO,EACAT,KAAKe,MACDf,KAAKa,IAAIN,GAAWP,KAAKa,IAAIH,GAAQV,KAAKc,IAAIN,GAC9CR,KAAKc,IAAIJ,GAAQV,KAAKa,IAAIL,GAAQR,KAAKa,IAAIF,KAE3BT,EAAUS,ICvBtC,IAAIK,EAAW,KA2JfC,IAAUC,OAAOC,iBAAiBF,IAAUG,cArI5C,SAAkBC,GAEhB,IAAMC,EAAQD,EAAkCE,OAE1CC,EAAcF,EAAKG,KAAL,IACdC,EAAiBJ,EAAKG,KAAL,OACjBE,EAAgBL,EAAKG,KAAL,MAQlBG,EAAgCC,YAASC,EAAsB,KAEnE,SAASA,IACP,IAAMC,EAAcC,gBAChBhB,EAAMe,EAAYf,IAClBiB,EAASjB,EAAIkB,YACbC,EAAOnB,EAAIoB,UACfnB,IAAUoB,kBAAkB,CAC1BC,aAAcP,EAAYQ,gBAC1BC,oBAAqBT,EAAYS,oBACjCC,aAAcV,EAAYU,aAC1BC,oBAAqBX,EAAYW,oBACjCT,OAAQA,EACRE,KAAMA,EACNQ,mBAAoBZ,EAAYY,mBAChCC,oBAAqBb,EAAYa,sBAQrC,SAASC,EAAOC,GACd,IAAMf,EAAcC,gBAEhBe,EAAOD,EAAEE,UACXC,EAAQH,EAAEG,MAEZ,GAAa,WAATF,EAAmB,CACrB,IAAIG,EAA2B,CAACD,EAAME,QAAQC,IAAKH,EAAME,QAAQxC,KAC7D0C,EAASJ,EAAMK,QAAQD,OACvBE,ED1CH,SAAyBL,EAA0BG,GAEtD,IAF2F,IAArBG,EAAoB,uDAAJ,GAClFC,EAAc,GACTC,EAAI,EAAGA,EAAIF,IAASE,EACzBD,EAAYE,KACRvD,EACI8C,EAAQG,EAAQxD,EAAc,EAAIG,KAAKC,GAAKyD,EAAKF,IAM7D,OAFAC,EAAYE,KAAKF,EAAY,IAEtB,CACHV,KAAM,UACNU,YAAa,CAACA,IC6BFG,CAAgBV,EAAQG,GACtCtB,EAAYY,mBAAqBU,EAAS,IAC1CtB,EAAYa,oBAAsBW,EAEpC,OAAOM,EAAaf,GAGtB,SAASe,EAAaf,GACpB,IAAMf,EAAcC,gBACpBD,EAAYS,oBAAsBM,EAAEgB,OACpC,IAAIC,EAAsB,GACtBjB,EAAEG,OAASH,EAAEG,MAAMe,YACrBjC,EAAYW,oBAAsBI,EAAEG,MAAMe,aAExCjC,EAAYkC,YAAYD,YAC1BD,EAAUhC,EAAYkC,YAAYD,YAAYE,UAEhDnC,EAAYU,aAAesB,EAC3BnC,IAGF,GAAW,MAAPZ,EACF,IACEA,EAAMgB,gBAAgBhB,IACtB,MAAO8B,GAGP,IAAMqB,EAAUC,SAASC,eAAe,WAClCC,EAAWF,SAASC,eAAe,YAKzC,GAJIC,IACFA,EAASC,MAAM7C,OAAf,UAA2BA,EAA3B,MACA4C,EAASC,MAAM5C,MAAf,UAA0BA,EAA1B,OAEEwC,EAAS,CAIX,GAHAA,EAAQI,MAAM7C,OAAd,UAA0BA,EAA1B,MACAyC,EAAQI,MAAM5C,MAAd,UAAyBA,EAAzB,OAE0D,IAAtDH,EAAIgD,QAAQ,qCAA6C,CAC3D,IAAIC,EAAIL,SAASM,cAAc,KAC/BD,EAAEE,KAAO,IACTF,EAAEG,GAAK,SACPH,EAAEI,UAAY,SACdT,SAASU,KAAKC,YAAYN,GAG5B,IAAMO,EAAgBZ,SAASM,cAAc,UAiBzCO,EAAWzD,EAbI,qZAcnBwD,EAAcH,UAAYI,EAC1Bb,SAASU,KAAKC,YAAYC,GAE1B,IACIhE,EADgBgB,gBACEhB,IAItB,IAAK,IAAIkE,KAFTlE,EAAImE,GAAG,SA3Gb,SAAoBrC,GACEd,gBACRO,gBAAkBO,EAAEgB,OAChClC,OAyGIZ,EAAImE,GAAG,WAnFb,SAAmBrC,GACjBlB,OAmFoBZ,EAAIoE,QAAS,CACfpE,EAAIoE,QAAQF,GAClBC,GAAG,QAAStB,GAEpB7C,EAAImE,GAAG,eAAgBtC,GACvB7B,EAAImE,GAAG,cAAetC,GACtB7B,EAAImE,GAAG,eAAgBtC,GAEvB5B,IAAUoE,iBACVvD,SAWRb,IAAUqE,oBAIVrE,IAAUoE,mB","file":"static/js/main.39c3035d.chunk.js","sourcesContent":["const earthRadius = 6378137; // equatorial Earth radius in m\n\nfunction toRadians(angleInDegrees: number) {\n    return (angleInDegrees * Math.PI) / 180;\n}\n\nfunction toDegrees(angleInRadians: number) {\n    return (angleInRadians * 180) / Math.PI;\n}\n\nfunction offset(\n    c1: [number, number],\n    distance: number,\n    earthRadius: number,\n    bearing: number): [number, number] {\n    var lat1 = toRadians(c1[1]);\n    var lon1 = toRadians(c1[0]);\n    var dByR = distance / earthRadius;\n    var lat = Math.asin(\n        Math.sin(lat1) * Math.cos(dByR) + Math.cos(lat1) * Math.sin(dByR) * Math.cos(bearing)\n    );\n    var lon =\n        lon1 +\n        Math.atan2(\n            Math.sin(bearing) * Math.sin(dByR) * Math.cos(lat1),\n            Math.cos(dByR) - Math.sin(lat1) * Math.sin(lat)\n        );\n    return [toDegrees(lon), toDegrees(lat)];\n}\n\nexport function circleToPolygon(center: [number, number], radius: number, sides: number = 32) {\n    var coordinates = [];\n    for (var i = 0; i < sides; ++i) {\n        coordinates.push(\n            offset(\n                center, radius, earthRadius, (2 * Math.PI * i) / sides\n            )\n        );\n    }\n    coordinates.push(coordinates[0]);\n\n    return {\n        type: \"Polygon\",\n        coordinates: [coordinates],\n    };\n};","import { Streamlit, RenderData } from \"streamlit-component-lib\";\nimport { debounce } from \"underscore\";\nimport { circleToPolygon } from \"./circle-to-polygon\";\n\nlet map: any = null;\n\ntype GlobalData = {\n  map: any;\n  lat_lng_clicked: any;\n  last_object_clicked: any;\n  last_active_drawing: any,\n  all_drawings: any,\n  bounds: any;\n  zoom: any;\n  drawn_items: any;\n  last_circle_radius: number;\n  last_circle_polygon: any;\n};\n\ndeclare var __GLOBAL_DATA__: GlobalData;\n\n/**\n * The component's render function. This will be called immediately after\n * the component is initially loaded, and then again every time the\n * component gets new data from Python.\n */\nfunction onRender(event: Event): void {\n  // Get the RenderData from the event\n  const data = (event as CustomEvent<RenderData>).detail\n\n  const fig: string = data.args[\"fig\"];\n  const height: number = data.args[\"height\"];\n  const width: number = data.args[\"width\"];\n\n  function onMapClick(e: any) {\n    const global_data = __GLOBAL_DATA__;\n    global_data.lat_lng_clicked = e.latlng;\n    debouncedUpdateComponentValue()\n  }\n\n  let debouncedUpdateComponentValue = debounce(updateComponentValue, 250)\n\n  function updateComponentValue() {\n    const global_data = __GLOBAL_DATA__;\n    let map = global_data.map;\n    let bounds = map.getBounds();\n    let zoom = map.getZoom();\n    Streamlit.setComponentValue({\n      last_clicked: global_data.lat_lng_clicked,\n      last_object_clicked: global_data.last_object_clicked,\n      all_drawings: global_data.all_drawings,\n      last_active_drawing: global_data.last_active_drawing,\n      bounds: bounds,\n      zoom: zoom,\n      last_circle_radius: global_data.last_circle_radius,\n      last_circle_polygon: global_data.last_circle_polygon,\n    })\n  }\n\n  function onMapMove(e: any) {\n    debouncedUpdateComponentValue()\n  }\n\n  function onDraw(e: any) {\n    const global_data = __GLOBAL_DATA__;\n\n    var type = e.layerType,\n      layer = e.layer;\n\n    if (type === \"circle\") {\n      var center: [number, number] = [layer._latlng.lng, layer._latlng.lat];\n      var radius = layer.options.radius; // In km\n      var polygon = circleToPolygon(center, radius);\n      global_data.last_circle_radius = radius / 1000; // Convert to km to match what UI shows\n      global_data.last_circle_polygon = polygon;\n    }\n    return onLayerClick(e);\n  }\n\n  function onLayerClick(e: any) {\n    const global_data = __GLOBAL_DATA__;\n    global_data.last_object_clicked = e.latlng;\n    let details: Array<any> = [];\n    if (e.layer && e.layer.toGeoJSON) {\n      global_data.last_active_drawing = e.layer.toGeoJSON();\n    }\n    if (global_data.drawn_items.toGeoJSON) {\n      details = global_data.drawn_items.toGeoJSON().features;\n    }\n    global_data.all_drawings = details;\n    debouncedUpdateComponentValue()\n  }\n\n  if (map == null) {\n    try {\n      map = __GLOBAL_DATA__.map;\n    } catch (e) {\n      // Only run this if the map hasn't already been created (and thus the global\n      //data hasn't been initialized)\n      const map_div = document.getElementById(\"map_div\");\n      const map_div2 = document.getElementById(\"map_div2\");\n      if (map_div2) {\n        map_div2.style.height = `${height}px`\n        map_div2.style.width = `${width}px`\n      }\n      if (map_div) {\n        map_div.style.height = `${height}px`\n        map_div.style.width = `${width}px`\n\n        if (fig.indexOf(\"document.getElementById('export')\") !== -1) {\n          let a = document.createElement(\"a\");\n          a.href = \"#\";\n          a.id = \"export\";\n          a.innerHTML = \"Export\";\n          document.body.appendChild(a);\n        }\n\n        const render_script = document.createElement(\"script\")\n        // HACK -- update the folium-generated JS to add, most importantly,\n        // the map to this global variable so that it can be used elsewhere\n        // in the script.\n        let set_global_data = `\n          window.__GLOBAL_DATA__ = {\n            map: map_div,\n            bounds: map_div.getBounds(),\n            lat_lng_clicked: null,\n            last_object_clicked: null,\n            all_drawings: null,\n            last_active_drawing: null,\n            zoom: null,\n            drawn_items: [],\n            last_circle_radius: null,\n            last_circle_polygon: null,\n        };`;\n        let replaced = fig + set_global_data;\n        render_script.innerHTML = replaced;\n        document.body.appendChild(render_script);\n\n        const global_data = __GLOBAL_DATA__;\n        let map = global_data.map;\n\n        map.on('click', onMapClick);\n        map.on('moveend', onMapMove);\n        for (let key in map._layers) {\n          let layer = map._layers[key];\n          layer.on(\"click\", onLayerClick)\n        }\n        map.on('draw:created', onDraw);\n        map.on('draw:edited', onDraw);\n        map.on('draw:deleted', onDraw);\n\n        Streamlit.setFrameHeight()\n        updateComponentValue();\n      }\n    }\n  }\n}\n\n// Attach our `onRender` handler to Streamlit's render event.\nStreamlit.events.addEventListener(Streamlit.RENDER_EVENT, onRender)\n\n// Tell Streamlit we're ready to start receiving data. We won't get our\n// first RENDER_EVENT until we call this function.\nStreamlit.setComponentReady()\n\n// Finally, tell Streamlit to update our initial height. We omit the\n// `height` parameter here to have it default to our scrollHeight.\nStreamlit.setFrameHeight()"],"sourceRoot":""}