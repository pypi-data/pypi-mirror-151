Metadata-Version: 2.1
Name: datadelve
Version: 0.8.2
Summary: A library to read and manipulate nested data structures, particularly ones read from JSON files
License: GPL-2.0+
Author: Nick Thurmes
Author-email: nthurmes@gmail.com
Requires-Python: >=3.6,<4.0
Classifier: License :: OSI Approved :: GNU General Public License v2 or later (GPLv2+)
Classifier: Programming Language :: Python :: 3
Classifier: Programming Language :: Python :: 3.10
Classifier: Programming Language :: Python :: 3.6
Classifier: Programming Language :: Python :: 3.7
Classifier: Programming Language :: Python :: 3.8
Classifier: Programming Language :: Python :: 3.9
Requires-Dist: jsonpointer (>=2.0,<3.0)
Description-Content-Type: text/markdown

# DataDelve
[![PyPI version](https://badge.fury.io/py/datadelve.svg)](https://badge.fury.io/py/datadelve)
[![Coverage Status](https://coveralls.io/repos/github/the-nick-of-time/datadelve/badge.svg?branch=master)](https://coveralls.io/github/the-nick-of-time/datadelve?branch=master)
[![Build Status](https://travis-ci.org/the-nick-of-time/datadelve.svg?branch=master)](https://travis-ci.org/the-nick-of-time/datadelve)

Working with complex nested data can be tedious. If you have to access any objects that are four layers deep in a JSON response from a web service, you quickly tire of writing square brackets.
Much better would be to have a simple way of accessing data through a simple syntax. 
[jsonpointer](https://tools.ietf.org/html/rfc6901) is a perfect match, it looks just like paths through a filesystem.
Applying this information to the data structures makes it easy and convenient.

## Usage

```python
from datadelve import DataDelver

data = ["your annoying data here"]
delver = DataDelver(data)
element = delver.get("/dict/keys/and/1/list/index")
subset = delver.cd("/particular/key/to/focus/on")
delver.set("/path/to/change", "new")
delver.delete("/bad")
```

