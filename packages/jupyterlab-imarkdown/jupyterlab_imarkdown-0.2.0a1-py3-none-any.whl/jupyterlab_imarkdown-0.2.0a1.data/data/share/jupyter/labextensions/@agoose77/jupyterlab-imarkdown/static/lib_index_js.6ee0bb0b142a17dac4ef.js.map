{"version":3,"file":"lib_index_js.6ee0bb0b142a17dac4ef.js","mappings":";;;;;;;;;;;;;;;AAA6C;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA,+EAA+E,MAAM;AACrF;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uFAAuF;AACvF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,sDAAe;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,MAAM;AAC1C;AACA;AACA,gCAAgC,sDAAe;AAC/C;AACA;AACA;AACO;AACP;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,eAAe;AAClD;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;ACrFiD;AACR;AACW;AACP;AACK;AACA;AAClD;AACO;AACA,4BAA4B,2DAAY;AAC/C;AACA;AACA;AACA;AACA,kCAAkC,8DAAe;AACjD;AACA,qCAAqC,2DAAmB;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4DAA4D,sDAAe;AAC3E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iGAAiG,MAAM;AACvG;AACA;AACA;AACA,iEAAiE,MAAM;AACvE;AACA;AACA;AACA,uCAAuC,oBAAoB;AAC3D;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,8DAAe;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qEAAqE,WAAW;AAChF;AACA;AACA;AACA;AACA,mCAAmC,2DAAkB;AACrD;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,YAAY,0DAAa;AACzB;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;;;;;;;;;;;;;;;;;;ACrJ0D;AACZ;AACvC,sCAAsC,mDAAM;AACnD;AACA;AACA;AACA;AACA;AACO,iCAAiC,mDAAM;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,4DAAe;AACzD;AACA;AACA;AACA;AACA;AACA,YAAY,2DAAQ;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,cAAc,IAAI,eAAe;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;ACzDwF;AAC/B;AAClB;AACM;AAC7C,sCAAsC,8EAA4B;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,gDAAa;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,+EAA6B;AAC3C,eAAe,mEAAe;AAC9B;AACA;AACA;AACA;AACA,6CAA6C,eAAe;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,kEAAgB;AAC/B;AACA;AACA;AACA,QAAQ,kFAAgC;AACxC,oBAAoB,iBAAiB;AACrC,YAAY,0DAAgB;AAC5B,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iEAAe,OAAO,EAAC;;;;;;;;;;;;;;;ACrDhB;;;;;;;;;;;;;;;;;;;ACAiD;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA,YAAY,0BAA0B;AACtC;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,2BAA2B,kEAAc;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;AChEO;AACP;AACA;AACO;AACP;AACA","sources":["webpack://@agoose77/jupyterlab-imarkdown/./lib/actions.js","webpack://@agoose77/jupyterlab-imarkdown/./lib/cell.js","webpack://@agoose77/jupyterlab-imarkdown/./lib/expression.js","webpack://@agoose77/jupyterlab-imarkdown/./lib/index.js","webpack://@agoose77/jupyterlab-imarkdown/./lib/metadata.js","webpack://@agoose77/jupyterlab-imarkdown/./lib/renderers.js","webpack://@agoose77/jupyterlab-imarkdown/./lib/user_expressions.js"],"sourcesContent":["import { metadataSection } from './metadata';\nfunction isMarkdownCell(cell) {\n    return cell.model.type === 'markdown';\n}\n/**\n * Load user expressions for given XMarkdown cell from kernel.\n * Store results in cell attachments.\n */\nexport async function executeUserExpressions(cell, sessionContext) {\n    var _a;\n    // Check we have a kernel\n    const kernel = (_a = sessionContext.session) === null || _a === void 0 ? void 0 : _a.kernel;\n    if (!kernel) {\n        throw new Error('Session has no kernel.');\n    }\n    const model = cell.model;\n    const cellId = { cellId: model.id };\n    // Build ordered map from string index to node\n    const namedExpressions = new Map(cell.expressions.map((expr, index) => [`${index}`, expr]));\n    // Extract expression values\n    const userExpressions = {};\n    namedExpressions.forEach((expr, key) => {\n        userExpressions[key] = expr;\n    });\n    // Populate request data\n    const content = {\n        code: '',\n        user_expressions: userExpressions\n    };\n    // Perform request\n    console.debug('Performing kernel request', content);\n    const future = kernel.requestExecute(content, false, Object.assign(Object.assign({}, model.metadata.toJSON()), cellId));\n    // Set response handler\n    future.onReply = (msg) => {\n        console.debug('Handling kernel response', msg);\n        // Only work with `ok` results\n        const content = msg.content;\n        if (content.status !== 'ok') {\n            console.error('Kernel response was not OK', msg);\n            return;\n        }\n        console.debug('Clear existing metadata');\n        // Clear metadata if present\n        cell.model.metadata.delete(metadataSection);\n        // Store results as metadata\n        const expressions = [];\n        for (const key in content.user_expressions) {\n            const expr = namedExpressions.get(key);\n            if (expr === undefined) {\n                console.error(\"namedExpressions doesn't have key. This should never happen\");\n                continue;\n            }\n            const result = content.user_expressions[key];\n            const expressionMetadata = {\n                expression: expr,\n                result: result\n            };\n            expressions.push(expressionMetadata);\n            console.debug(`Saving ${expr} to cell attachments`, expressionMetadata);\n        }\n        // Update cell metadata\n        cell.model.metadata.set(metadataSection, expressions);\n    };\n    await future.done;\n}\nexport function notebookExecuted(notebook, cell, tracker) {\n    // Find the Notebook panel\n    const panel = tracker.find((w) => {\n        return w.content === notebook;\n    });\n    // Retrieve the kernel context\n    const ctx = panel === null || panel === void 0 ? void 0 : panel.sessionContext;\n    if (ctx === undefined) {\n        return;\n    }\n    // Load the user expressions for the given cell.\n    if (!isMarkdownCell(cell)) {\n        return;\n    }\n    console.debug(`Markdown cell ${cell.model.id} was executed, waiting for render to complete ...`);\n    cell.doneRendering\n        .then(() => executeUserExpressions(cell, ctx))\n        .catch(console.error)\n        .then(() => cell.renderExpressionsFromMetadata())\n        .catch(console.error);\n}\n","import { MarkdownCell } from '@jupyterlab/cells';\nimport { Widget } from '@lumino/widgets';\nimport { PromiseDelegate } from '@lumino/coreutils';\nimport { metadataSection } from './metadata';\nimport { textRendererFactory } from './renderers';\nimport { RenderedExpression } from './expression';\n// CSS class for expression nodes\nexport const EXPR_CLASS = 'eval-expr';\nexport class IMarkdownCell extends MarkdownCell {\n    constructor(options) {\n        super(options);\n        this.__lastContent = '';\n        this._expressions = [];\n        this._doneRendering = new PromiseDelegate();\n        this.__rendermime = options.rendermime.clone();\n        this.__rendermime.addFactory(textRendererFactory);\n        this._expressions = [];\n        // Dispose of existing expressions\n        this._triageElement = document.createElement('div');\n        this._triageElement.setAttribute('visibility', 'hidden');\n        this.node.appendChild(this._triageElement);\n    }\n    /**\n     * Get an array of names to kernel expressions.\n     */\n    get expressions() {\n        return this._expressions.map(node => node.expression);\n    }\n    /**\n     * Whether the Markdown renderer has finished rendering.\n     */\n    get doneRendering() {\n        return this._doneRendering.promise;\n    }\n    /**\n     * Update rendered expressions from current attachment MIME-bundles\n     */\n    renderExpressionsFromMetadata() {\n        console.debug('Rendering expressions', this.expressions);\n        const expressionsMetadata = this.model.metadata.get(metadataSection);\n        if (expressionsMetadata === undefined) {\n            console.debug('Aborting rendering of expressions: no metadata', this.expressions);\n            return Promise.reject();\n        }\n        // Check we have enough keys\n        if (expressionsMetadata.length !== this._expressions.length) {\n            console.error('Aborting rendering of expressions: expressions mismatch', this.expressions, expressionsMetadata);\n            return Promise.reject();\n        }\n        // Loop over expressions and render them from the cell attachments\n        const promises = [];\n        this._expressions.forEach((node, index) => {\n            const metadata = expressionsMetadata[index];\n            // Can't render the remaining keys. Should we have aborted earlier?\n            if (metadata.expression !== node.expression) {\n                console.error(`Metadata expression does not match Markdown expression at index ${index}`);\n                return;\n            }\n            if (metadata.result === undefined) {\n                console.error(`Metadata has no result at index ${index}`);\n                return;\n            }\n            // Create element and replace it in the parent's DOM tree\n            console.debug(`Rendering ${metadata.expression}`);\n            // Update the placeholder once rendered\n            promises.push(node.renderExpression(metadata.result));\n        });\n        return Promise.all(promises).then();\n    }\n    /**\n     * Wait for Markdown rendering to complete.\n     * Assume that rendered container will have at least one child.\n     */\n    _waitForRender(widget, timeout) {\n        // FIXME: this is a HACK\n        return new Promise(resolve => {\n            function waitReady() {\n                const firstChild = widget.node.querySelector('.jp-RenderedMarkdown *');\n                if (firstChild !== null) {\n                    return resolve();\n                }\n                setTimeout(waitReady, timeout);\n            }\n            waitReady();\n        });\n    }\n    renderInput(widget) {\n        // Therefore, this is sometimes executed before the DOM is updated.\n        super.renderInput(widget);\n        const currentContent = this.model.value.text;\n        // If the content has changed\n        if (this.__lastContent !== undefined && // Not sure why this happens, but run with it.\n            this.__lastContent !== currentContent) {\n            this._doneRendering = new PromiseDelegate();\n            // Wait for rendering to complete\n            this._waitForRender(widget, 2)\n                .then(() => {\n                this._clearExpressions();\n                // Identify markup expressions by placeholders\n                this._identifyExpressions(widget);\n                // Replace placeholders with content from attachments\n                return this.renderExpressionsFromMetadata();\n            })\n                .catch(console.error)\n                .then(() => {\n                this._doneRendering.resolve();\n            });\n            this.__lastContent = currentContent;\n        }\n    }\n    /**\n     * Dispose of the rendered expressions\n     */\n    _clearExpressions() {\n        console.debug('Clearing expressions');\n        if (this._expressions !== undefined && this._triageElement !== undefined) {\n            this._expressions.forEach(expr => {\n                if (!document.body.contains(expr.node)) {\n                    this._triageElement.appendChild(expr.node);\n                }\n                expr.dispose();\n            });\n        }\n        this._expressions = [];\n    }\n    /**\n     * Parse the rendered markdown, and store placeholder and expression mappings\n     */\n    _identifyExpressions(widget) {\n        const exprInputNodes = widget.node.querySelectorAll(`input.${EXPR_CLASS}`);\n        // Store expressions & their current placeholders\n        this._expressions = [...exprInputNodes].map((elem) => {\n            const element = elem;\n            // Create expression\n            const expression = new RenderedExpression({\n                expression: element.value,\n                trusted: this.model.trusted,\n                rendermime: this.__rendermime,\n                safe: 'any'\n            });\n            // Inject widget into DOM\n            Widget.attach(expression, element.parentElement || widget.node, element);\n            console.assert(expression.isAttached, 'expr should be attached', expression);\n            element.remove();\n            // Return expression node\n            return expression;\n        });\n        console.debug('Found expressions', this._expressions);\n    }\n}\n","import { SingletonLayout, Widget } from '@lumino/widgets';\nimport { isOutput } from './user_expressions';\nexport class RenderedExpressionError extends Widget {\n    constructor() {\n        super();\n        this.addClass('im-RenderedExpressionError');\n    }\n}\nexport class RenderedExpression extends Widget {\n    constructor(options) {\n        super();\n        this.trusted = options.trusted;\n        this.expression = options.expression;\n        this.rendermime = options.rendermime;\n        this.safe = options.safe;\n        this.addClass('im-RenderedExpression');\n        // We can only hold one renderer at a time\n        const layout = (this.layout = new SingletonLayout());\n        layout.widget = new RenderedExpressionError();\n    }\n    renderExpression(payload) {\n        const layout = this.layout;\n        let options;\n        if (isOutput(payload)) {\n            // Output results are simple to reinterpret\n            options = {\n                trusted: this.trusted,\n                data: payload.data,\n                metadata: payload.metadata\n            };\n        }\n        else {\n            // Errors need to be formatted as stderr objects\n            options = {\n                data: {\n                    'application/vnd.jupyter.stderr': payload.traceback.join('\\n') ||\n                        `${payload.ename}: ${payload.evalue}`\n                }\n            };\n        }\n        // Invoke MIME renderer\n        const model = this.rendermime.createModel(options);\n        // Select preferred mimetype for bundle\n        const mimeType = this.rendermime.preferredMimeType(model.data, this.safe);\n        if (mimeType === undefined) {\n            console.error(\"Couldn't find mimetype for \", model);\n            // Create error\n            layout.widget = new RenderedExpressionError();\n            return Promise.resolve();\n        }\n        // Create renderer\n        const renderer = this.rendermime.createRenderer(mimeType);\n        layout.widget = renderer;\n        console.assert(renderer.isAttached, 'renderer was not attached!', renderer);\n        // Render model\n        return renderer.renderModel(model);\n    }\n}\n","import { INotebookTracker, NotebookActions, NotebookPanel } from '@jupyterlab/notebook';\nimport { IEditorServices } from '@jupyterlab/codeeditor';\nimport { IMarkdownCell } from './cell';\nimport { notebookExecuted } from './actions';\nclass IMarkdownContentFactory extends NotebookPanel.ContentFactory {\n    /**\n     * Create a new markdown cell widget.\n     *\n     * #### Notes\n     * If no cell content factory is passed in with the options, the one on the\n     * notebook content factory is used.\n     */\n    createMarkdownCell(options, parent) {\n        if (!options.contentFactory) {\n            options.contentFactory = this;\n        }\n        return new IMarkdownCell(options).initializeState();\n    }\n}\n/**\n * The notebook cell factory provider.\n */\nconst factory = {\n    id: '@agoose77/jupyterlab-imarkdown:factory',\n    provides: NotebookPanel.IContentFactory,\n    requires: [IEditorServices],\n    autoStart: true,\n    activate: (app, editorServices) => {\n        console.log('Using jupyterlab-imarkdown:editor');\n        const editorFactory = editorServices.factoryService.newInlineEditor;\n        return new IMarkdownContentFactory({ editorFactory });\n    }\n};\n/**\n * The notebook cell executor.\n */\nconst executor = {\n    id: '@agoose77/jupyterlab-imarkdown:executor',\n    requires: [INotebookTracker],\n    autoStart: true,\n    activate: (app, tracker) => {\n        console.log('Using jupyterlab-imarkdown:executor');\n        NotebookActions.executed.connect((sender, value) => {\n            const { notebook, cell } = value;\n            notebookExecuted(notebook, cell, tracker);\n        });\n        return;\n    }\n};\n/**\n * Export the plugins as default.\n */\nconst plugins = [factory, executor];\nexport default plugins;\n","export const metadataSection = 'user_expressions';\n","import { RenderedCommon } from '@jupyterlab/rendermime';\n/**\n * Render text into a host node.\n *\n * @param options - The options for rendering.\n *\n * @returns A promise which resolves when rendering is complete.\n */\nexport function renderText(options) {\n    // Unpack the options.\n    const { host, sanitizer, source } = options;\n    // Create the raw text content.\n    let content;\n    content = sanitizer.sanitize(source, {\n        allowedTags: []\n    });\n    // Remove quotes if required\n    if (options.strip_quotes) {\n        content = content.replace(/^([\"'])(.*)\\1$/, '$2');\n    }\n    // Set the sanitized content for the host node.\n    const span = document.createElement('span');\n    span.innerHTML = content;\n    host.appendChild(span);\n    // Return the rendered promise.\n    return Promise.resolve(undefined);\n}\n/**\n * A widget for displaying plain text.\n */\nexport class RenderedText extends RenderedCommon {\n    /**\n     * Construct a new rendered text widget.\n     *\n     * @param options - The options for initializing the widget.\n     */\n    constructor(options) {\n        super(options);\n        this.addClass('im-RenderedText');\n    }\n    /**\n     * Render a mime model.\n     *\n     * @param model - The mime model to render.\n     *\n     * @returns A promise which resolves when rendering is complete.\n     */\n    render(model) {\n        return renderText({\n            host: this.node,\n            sanitizer: this.sanitizer,\n            source: String(model.data[this.mimeType]),\n            strip_quotes: true\n        });\n    }\n}\n/**\n * A mime renderer factory for plain and jupyter console text data.\n */\nexport const textRendererFactory = {\n    safe: true,\n    mimeTypes: ['text/plain'],\n    defaultRank: 100,\n    createRenderer: options => new RenderedText(options)\n};\n","export function isOutput(output) {\n    return output.status === 'ok';\n}\nexport function isError(output) {\n    return output.status === 'error';\n}\n"],"names":[],"sourceRoot":""}