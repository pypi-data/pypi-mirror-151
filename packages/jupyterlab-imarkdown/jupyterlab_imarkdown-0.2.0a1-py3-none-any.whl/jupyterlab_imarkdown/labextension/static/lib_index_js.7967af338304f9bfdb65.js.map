{"version":3,"file":"lib_index_js.7967af338304f9bfdb65.js","mappings":";;;;;;;;;;;;;;;;;;;;;;;AAAiD;AACT;AACY;AACP;AACC;AAC9C;AACO;AACP;AACO;AACP;AACO;AACA,4BAA4B,2DAAY;AAC/C;AACA;AACA;AACA;AACA,mCAAmC,8DAAe;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,2DAAQ;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,cAAc,IAAI,eAAe;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4DAA4D,sDAAe;AAC3E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+FAA+F,MAAM;AACrG;AACA;AACA;AACA,+DAA+D,MAAM;AACrE;AACA;AACA,qCAAqC,qBAAqB,OAAO,aAAa;AAC9E;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,8DAAe;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qEAAqE,iDAAU,CAAC;AAChF;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;AC7JkC;AACsD;AAC/B;AAClB;AACQ;AAC/C,sCAAsC,8EAA4B;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,gDAAa;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,+EAA6B;AAC3C,eAAe,mEAAe;AAC9B;AACA;AACA;AACA;AACA,6CAA6C,eAAe;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,kEAAgB;AAC/B;AACA;AACA;AACA,yBAAyB,0EAAwB;AACjD;AACA,oBAAoB,iBAAiB;AACrC;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,4DAAmB;AACnC;AACA;AACA,iBAAiB;AACjB,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,2CAAM;AAC1C,iEAAe,OAAO,EAAC;;;;;;;;;;;;;;;;ACnFsB;AAC7C;AACA;AACA;AACA;AACO;AACP;AACA;AACA,qBAAqB;AACrB;AACA,+EAA+E,MAAM;AACrF;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uFAAuF;AACvF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,sDAAe;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,kCAAkC,MAAM;AACxC;AACA;AACA,gCAAgC,sDAAe;AAC/C;AACA,SAAS;AACT;AACA;AACA;;;;;;;;;;;;;;;AC1DO;;;;;;;;;;;;;;;;;;ACAuC;AACuB;AACrE;AACA;AACA;AACA;AACO,eAAe,mFAAsB;AAC5C;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,gBAAgB,uDAAgB;AAChC;AACA,CAAC;;;;;;;;;;;;;;;;AChBM;AACA;AACP;AACA,qIAAqI;AACrI,uIAAuI;AACvI;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;AC9CO;AACP;AACA;AACO;AACP;AACA","sources":["webpack://jupyterlab-imarkdown/./lib/cell.js","webpack://jupyterlab-imarkdown/./lib/index.js","webpack://jupyterlab-imarkdown/./lib/kernel.js","webpack://jupyterlab-imarkdown/./lib/metadata.js","webpack://jupyterlab-imarkdown/./lib/plugin.js","webpack://jupyterlab-imarkdown/./lib/tokenize.js","webpack://jupyterlab-imarkdown/./lib/user_expressions.js"],"sourcesContent":["import { MarkdownCell } from '@jupyterlab/cells';\nimport { EXPR_CLASS } from './tokenize';\nimport { PromiseDelegate } from '@lumino/coreutils';\nimport { metadataSection } from './metadata';\nimport { isOutput } from './user_expressions';\n// Base CSS class for jupyterlab-imarkdown outputs\nexport const RENDERED_CLASS = 'im-rendered';\n// CSS class for execution-result outputs\nexport const RESULT_CLASS = 'im-result';\n// CSS class for missing outputs\nexport const ERROR_CLASS = 'im-error';\nexport class XMarkdownCell extends MarkdownCell {\n    constructor(options) {\n        super(options);\n        this.__expressions = [];\n        this.__lastContent = '';\n        this.__doneRendering = new PromiseDelegate();\n        this.__rendermime = options.rendermime;\n    }\n    /**\n     * Create an IRenderMime.IMimeModel for a given IExpressionResult\n     */\n    renderExpressionResultModel(payload) {\n        let options;\n        if (isOutput(payload)) {\n            // Output results are simple to reinterpret\n            options = {\n                trusted: this.model.trusted,\n                data: payload.data,\n                metadata: payload.metadata\n            };\n        }\n        else {\n            // Errors need to be formatted as stderr objects\n            options = {\n                data: {\n                    'application/vnd.jupyter.stderr': payload.traceback.join('\\n') ||\n                        `${payload.ename}: ${payload.evalue}`\n                }\n            };\n        }\n        // Invoke MIME rendere\n        const model = this.__rendermime.createModel(options);\n        // Select preferred mimetype for bundle\n        // FIXME: choose appropriate value for `safe`\n        const mimeType = this.__rendermime.preferredMimeType(model.data, 'any');\n        if (mimeType === undefined) {\n            console.error(\"Couldn't find mimetype\");\n            // Return error result\n            const node = document.createElement('span');\n            node.classList.add(RENDERED_CLASS);\n            node.classList.add(ERROR_CLASS);\n            return node;\n        }\n        // Create renderer\n        const renderer = this.__rendermime.createRenderer(mimeType);\n        renderer.addClass(RENDERED_CLASS);\n        renderer.addClass(RESULT_CLASS);\n        // Render model\n        renderer.renderModel(model);\n        return renderer.node;\n    }\n    /**\n     * Get an array of names to kernel expressions.\n     */\n    get expressions() {\n        return this.__expressions.map(node => node.expression);\n    }\n    /**\n     * Whether the Markdown renderer has finished rendering.\n     */\n    get doneRendering() {\n        return this.__doneRendering.promise;\n    }\n    /**\n     * Update rendered expressions from current attachment MIME-bundles\n     */\n    renderExpressions() {\n        console.log('Rendering expressions', this.expressions);\n        const expressionsMetadata = this.model.metadata.get(metadataSection);\n        if (expressionsMetadata === undefined) {\n            return;\n        }\n        // Check we have enough keys\n        if (expressionsMetadata.length !== this.__expressions.length) {\n            return;\n        }\n        // Loop over expressions and render them from the cell attachments\n        this.__expressions.forEach((node, index) => {\n            var _a;\n            const metadata = expressionsMetadata[index];\n            // Can't render the remaining keys. Should we have aborted earlier?\n            if (metadata.expression !== node.expression) {\n                console.log(`Metadata expression does not match Markdown expression at index ${index}`);\n                return;\n            }\n            if (metadata.result === undefined) {\n                console.log(`Metadata has no result at index ${index}`);\n                return;\n            }\n            console.log(`Rendering ${metadata.expression} into ${node.element}`);\n            const element = this.renderExpressionResultModel(metadata.result);\n            (_a = node.element.parentNode) === null || _a === void 0 ? void 0 : _a.replaceChild(element, node.element);\n            node.element = element;\n        });\n    }\n    /**\n     * Wait for Markdown rendering to complete.\n     * Assume that rendered container will have at least one child.\n     */\n    _waitForRender(widget, timeout) {\n        // FIXME: this is a HACK\n        return new Promise(resolve => {\n            function waitReady() {\n                const firstChild = widget.node.querySelector('.jp-RenderedMarkdown *');\n                if (firstChild !== null) {\n                    return resolve();\n                }\n                setTimeout(waitReady, timeout);\n            }\n            waitReady();\n        });\n    }\n    renderInput(widget) {\n        // FIXME: `renderInput` is called without waiting for render future to finish\n        // Therefore, this is sometimes executed before the DOM is updated.\n        super.renderInput(widget);\n        const currentContent = this.model.value.text;\n        // If the content has changed\n        if (this.__lastContent !== currentContent) {\n            this.__doneRendering = new PromiseDelegate();\n            // Wait for rendering to complete\n            this._waitForRender(widget, 2).then(() => {\n                // Identify markup expressions by placeholders\n                this._identifyExpressions(widget);\n                // Replace placeholders with content from attachments\n                this.renderExpressions();\n                this.__doneRendering.resolve();\n            });\n            this.__lastContent = currentContent;\n        }\n    }\n    /**\n     * Parse the rendered markdown, and store placeholder and expression mappings\n     */\n    _identifyExpressions(widget) {\n        const exprInputNodes = widget.node.querySelectorAll(`input.${EXPR_CLASS}`);\n        // Store expressions & their current placeholders\n        this.__expressions = [];\n        exprInputNodes.forEach((elem, index) => {\n            this.__expressions.push({\n                expression: elem.value,\n                element: elem\n            });\n        });\n        console.log('Found expressions', this.__expressions);\n    }\n}\n","import { plugin } from './plugin';\nimport { INotebookTracker, NotebookActions, NotebookPanel } from '@jupyterlab/notebook';\nimport { IEditorServices } from '@jupyterlab/codeeditor';\nimport { XMarkdownCell } from './cell';\nimport { loadUserExpressions } from './kernel';\nclass XMarkdownContentFactory extends NotebookPanel.ContentFactory {\n    /**\n     * Create a new markdown cell widget.\n     *\n     * #### Notes\n     * If no cell content factory is passed in with the options, the one on the\n     * notebook content factory is used.\n     */\n    createMarkdownCell(options, parent) {\n        if (!options.contentFactory) {\n            options.contentFactory = this;\n        }\n        return new XMarkdownCell(options).initializeState();\n    }\n}\n/**\n * The notebook cell factory provider.\n */\nconst factory = {\n    id: '@agoose77/jupyterlab-imarkdown:factory',\n    provides: NotebookPanel.IContentFactory,\n    requires: [IEditorServices],\n    autoStart: true,\n    activate: (app, editorServices) => {\n        console.log('Using jupyterlab-imarkdown:editor');\n        const editorFactory = editorServices.factoryService.newInlineEditor;\n        return new XMarkdownContentFactory({ editorFactory });\n    }\n};\nfunction isMarkdownCell(cell) {\n    return cell.model.type === 'markdown';\n}\nfunction removeKernelAttachments(cell) {\n    // const attachments = cell.model.attachments;\n}\n/**\n * The notebook cell executor.\n */\nconst executor = {\n    id: '@agoose77/jupyterlab-imarkdown:executor',\n    requires: [INotebookTracker],\n    autoStart: true,\n    activate: (app, tracker) => {\n        console.log('Using jupyterlab-imarkdown:executor');\n        const executed = NotebookActions.executed;\n        executed.connect((sender, value) => {\n            const { notebook, cell } = value;\n            // Find the Notebook panel\n            const panel = tracker.find((w) => {\n                return w.content === notebook;\n            });\n            // Retrieve the kernel context\n            const ctx = panel === null || panel === void 0 ? void 0 : panel.sessionContext;\n            if (ctx === undefined) {\n                return;\n            }\n            // Load the user expressions for the given cell.\n            if (!isMarkdownCell(cell)) {\n                return;\n            }\n            console.log('Markdown cell was executed, waiting for render to complete ...');\n            cell.doneRendering.then(() => {\n                console.log('Clearing results from cell attachments');\n                removeKernelAttachments(cell);\n                console.log('Loading results from kernel');\n                loadUserExpressions(cell, ctx).then(() => {\n                    console.log('Re-rendering cell!');\n                    cell.renderExpressions();\n                });\n            });\n        });\n        return;\n    }\n};\n/**\n * Export the plugins as default.\n */\nconst plugins = [factory, executor, plugin];\nexport default plugins;\n","import { metadataSection } from './metadata';\n/**\n * Load user expressions for given XMarkdown cell from kernel.\n * Store results in cell attachments.\n */\nexport async function loadUserExpressions(cell, sessionContext) {\n    var _a;\n    const model = cell.model;\n    const cellId = { cellId: model.id };\n    // Build ordered map from string index to node\n    const namedExpressions = new Map(cell.expressions.map((expr, index) => [`${index}`, expr]));\n    // Extract expression values\n    const userExpressions = {};\n    namedExpressions.forEach((expr, key) => {\n        userExpressions[key] = expr;\n    });\n    // Populate request data\n    const content = {\n        code: '',\n        user_expressions: userExpressions\n    };\n    // Check we have a kernel\n    const kernel = (_a = sessionContext.session) === null || _a === void 0 ? void 0 : _a.kernel;\n    if (!kernel) {\n        throw new Error('Session has no kernel.');\n    }\n    // Perform request\n    console.log('Performing kernel request', cell.expressions);\n    const future = kernel.requestExecute(content, false, Object.assign(Object.assign({}, model.metadata.toJSON()), cellId));\n    // Set response handler\n    future.onReply = (msg) => {\n        const content = msg.content;\n        if (content.status !== 'ok') {\n            return;\n        }\n        console.log('Handling kernel response', msg);\n        // Clear metadata if present\n        cell.model.metadata.delete(metadataSection);\n        // Store results as metadata\n        const expressions = [];\n        for (const key in content.user_expressions) {\n            const expr = namedExpressions.get(key);\n            if (expr === undefined) {\n                continue;\n            }\n            const result = content.user_expressions[key];\n            expressions.push({\n                expression: expr,\n                result: result\n            });\n            console.log(`Saving ${expr} to cell attachments`);\n        }\n        // Update cell metadata\n        cell.model.metadata.set(metadataSection, {\n            expressions: expressions\n        });\n    };\n    await future.done;\n}\n","export const metadataSection = 'user_expressions';\n","import { expressionPlugin } from './tokenize';\nimport { simpleMarkdownItPlugin } from '@agoose77/jupyterlab-markup';\nconst PACKAGE_NS = '@agoose77/jupyterlab-imarkdown';\n/**\n * Captures expressions as data-attributes\n */\nexport const plugin = simpleMarkdownItPlugin(PACKAGE_NS, {\n    id: 'markdown-it-expression',\n    title: 'Create spans with stored expressions from Markdown',\n    description: 'Embed Markdown text in a data attribute in rendered spans',\n    documentationUrls: {\n        Plugin: '...'\n    },\n    plugin: async () => {\n        return [expressionPlugin];\n    }\n});\n","export const EXPR_CLASS = 'eval-expr';\nexport function expressionPlugin(md, options) {\n    var _a, _b;\n    const openDelim = (_a = options === null || options === void 0 ? void 0 : options.openDelim) !== null && _a !== void 0 ? _a : '{{';\n    const closeDelim = (_b = options === null || options === void 0 ? void 0 : options.closeDelim) !== null && _b !== void 0 ? _b : '}}';\n    function tokenize(state, silent) {\n        // Check we start with the correct markers\n        let pos = state.pos;\n        // For performance, just check first character\n        if (state.src[pos] !== openDelim[0]) {\n            return false;\n        }\n        // Does the full substring match?\n        if (state.src.slice(pos, pos + openDelim.length) !== openDelim) {\n            return false;\n        }\n        pos += openDelim.length;\n        // First index _after_ {{\n        const startPos = pos;\n        // Find end marker }}\n        let stopPos = -1;\n        while (stopPos === -1) {\n            // Find first character of end marker\n            pos = state.src.indexOf(closeDelim[0], pos);\n            // Didn't find character\n            if (pos === -1) {\n                return false;\n            }\n            // If subsequent tokens don't match, just advance by one token!\n            if (state.src.slice(pos, pos + closeDelim.length) !== closeDelim) {\n                pos++;\n                continue;\n            }\n            stopPos = pos;\n            pos += closeDelim.length;\n        }\n        // Read tokens inside of the bracket\n        const expression = state.src.slice(startPos, stopPos);\n        state.pos = pos;\n        const exprToken = state.push('expr', 'input', 0);\n        exprToken.attrSet('type', 'hidden');\n        exprToken.attrSet('class', EXPR_CLASS);\n        exprToken.attrSet('value', expression);\n        return true;\n    }\n    md.inline.ruler.after('emphasis', 'expr', tokenize);\n}\n","export function isOutput(output) {\n    return output.status === 'ok';\n}\nexport function isError(output) {\n    return output.status === 'error';\n}\n"],"names":[],"sourceRoot":""}